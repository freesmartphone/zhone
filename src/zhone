#!/usr/bin/env python
#coding=utf8
"""
Zen Phone - A Phone UI

(C) 2007 Johannes 'Josch' Schauer
(C) 2008 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
(C) 2008 Jan 'Shoragan' Luebbe
(C) 2008 Daniel 'Alphaone' Willmann
(C) 2008 Openmoko, Inc.
GPLv2 or later
"""

#----------------------------------------------------------------------------#
WIDTH = 480
HEIGHT = 640

TITLE = "zhone"
WM_NAME = "zhone"
WM_CLASS = "zhone"

#----------------------------------------------------------------------------#
import os
import sys
import e_dbus
import evas
import evas.decorators
import edje
import edje.decorators
import ecore
import ecore.evas
from dbus import SystemBus, Interface
from dbus.exceptions import DBusException
from optparse import OptionParser
import time

#----------------------------------------------------------------------------#

edjepaths = "../data/themes/zhone.edj ../share/zhone.edj /usr/local/share/zhone/zhone.edj /usr/share/zhone/zhone.edj".split()

for i in edjepaths:
    if os.path.exists( i ):
       global edjepath
       edjepath = i
       break
else:
    raise Exception( "zhone.edj not found. looked in %s" % edjepaths )

#----------------------------------------------------------------------------#
class edje_group(edje.Edje):
#----------------------------------------------------------------------------#
    def __init__(self, main, group):
        self.main = main
        global edjepath
        f = edjepath
        try:
            edje.Edje.__init__(self, self.main.evas_canvas.evas_obj.evas, file=f, group=group)
        except edje.EdjeLoadError, e:
            raise SystemExit("error loading %s: %s" % (f, e))
        self.size = self.main.evas_canvas.evas_obj.evas.size

    @edje.decorators.signal_callback("transition:*", "*")
    def on_edje_signal_transition(self, emission, source):
        target = emission.split(':')[1]
        if target == "phone" and not self.main.groups["call"].status in ["idle" , "release"]:
            target = "call"
        if target == "phone":
            if ( dbus_object.gsm_device_obj is not None ) and dbus_object.gsm_network_iface.GetStatus()["registration"] == 'unregistered':
                try:
                    dbus_object.gsm_device_iface.SetAntennaPower(True)
                    dbus_object.gsm_network_iface.Register()
                except DBusException, e:
                    # TODO handle this better
                    print e
                    try:
                        authstatus = dbus_object.gsm_sim_iface.GetAuthStatus()
                        if authstatus == "SIM PUK":
                            target = "puk"
                        elif authstatus == "SIM PIN":
                            target = "pin"
                    except DBusException, e:
                        print e

        self.main.transition_to(target)

    @edje.decorators.signal_callback("finished_transition", "*")
    def on_edje_signal_finished_transition(self, emission, source):
        self.main.transition_finished()

#----------------------------------------------------------------------------#
class pyphone_main(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "main")

#----------------------------------------------------------------------------#
class pyphone_phone(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "phone")
        self.text = []

    @edje.decorators.signal_callback("dialer_button_pressed", "*")
    def on_edje_signal_dialer_button_pressed(self, emission, source):
        if "button_" in source:
            key = source.split("_", 1)[1]
            if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "#"):
                self.text.append(key)
                # The trailing whitespace is a workaround for the one char invisible
                # bug due to some problems with scaling of text parts.
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "star":
                self.text.append("*")
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "delete":
                self.text = self.text[:-1]
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "dial":
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_call_iface.Initiate("".join(self.text), "voice")
                else:
                    # Fake onCallStatus...
                    self.main.groups["call"].onCallStatus( None, "outgoing", {"number": "".join(self.text)} )
        else:
            key = source
        #self.text.append(source)
        #self.part_text_set("label", "".join(self.text))

#----------------------------------------------------------------------------#
class pyphone_call(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "call")
        self.update_status("idle")
        self.call = None

    def onCallStatus( self, id, status, properties ):
        self.call = id
        self.update_status(status)
        try:
            self.part_text_set( "label", properties[ "peer" ] )
        except KeyError:
            pass

    @edje.decorators.signal_callback("call_button_pressed", "button_left")
    def on_edje_signal_call_button_left_pressed(self, emission, source):
        if self.status == "active":
            if dbus_object.gsm_device_obj:
                #dbus_object.gsm_call_iface.Hold(self.call)
                pass
            else:
                self.update_status("held")
        elif self.status in ["incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Activate(self.call)
            else:
                self.update_status("active")

    @edje.decorators.signal_callback("call_button_pressed", "button_right")
    def on_edje_signal_call_button_right_pressed(self, emission, source):
        if self.status in ["outgoing", "active", "incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Release(self.call)
            else:
                self.update_status("release")

    def update_status(self, status):
        self.part_text_set( "label_description", status )
        if status == "outgoing":
            self.part_text_set( "label_left", "" )
            self.part_text_set( "label_right", "cancel" )
        elif status == "active":
            self.part_text_set( "label_left", "hold" )
            self.part_text_set( "label_right", "hangup" )
        elif status == "incoming":
            self.part_text_set( "label_left", "answer" )
            self.part_text_set( "label_right", "reject" )
        elif status == "held":
            self.part_text_set( "label_left", "resume" )
            self.part_text_set( "label_right", "hangup" )
        else:
            self.part_text_set( "label_left", "" )
            self.part_text_set( "label_right", "" )
        if status in ["incoming", "outgoing"] and not self.status == status:
            # TODO make sure we get displayed
            if not self.main.in_transition:
                self.main.transition_to("call")
        self.status = status

#----------------------------------------------------------------------------#
class pyphone_contacts(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "contacts")

    def cbMenu( self, result ):
        print result

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        self.signal_emit( "deactivate_button_list_0", "" )
        self.signal_emit( "deactivate_button_list_1", "" )
        self.signal_emit( "deactivate_button_list_2", "" )
        self.signal_emit( "deactivate_button_list_3", "" )
        self.signal_emit( "deactivate_button_list_4", "" )
        self.signal_emit( "deactivate_button_list_5", "" )
        self.signal_emit( "activate_button_list_%i" % id, "" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
    	self.main.groups["menu"].activate(("edit name", "edit number", "new", "delete"), self.cbMenu)

#----------------------------------------------------------------------------#
class pyphone_sms(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "sms")
        self.text = []
        self.button_labels2 = [
            [
                [".,?!", "abc", "def", ""],
                ["ghi", "jkl", "mno", ""],
                ["pqrs", "tuv", "wxyz", ""],
                ["", "", "⇦⇧⇨", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.button_labels = [
            [
                ["1", "2", "3", "↤"],
                ["4", "5", "6", "↲"],
                ["7", "8", "9", "Abc"],
                ["+", "0", "⇩", "+"],
            ],
            [
                ["1", "?", "", ""],
                [".", ",", "", ""],
                ["!", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "2", "c", ""],
                ["", "a", "b", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "3", "f"],
                ["", "", "d", "e"],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", "↤"],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["4", "i", "", ""],
                ["g", "h", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "5", "l", ""],
                ["", "j", "k", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "6", "o"],
                ["", "", "m", "n"],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "s", "", ""],
                ["7", "r", "", ""],
                ["p", "q", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "8", "v", ""],
                ["", "t", "u", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", "z"],
                ["", "", "9", "y"],
                ["", "", "w", "x"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", " ", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "⇧", ""],
                ["", "⇦", "⇩", "⇨"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.set_button_text(0)
        self.active = 0

    @edje.decorators.signal_callback("kb_button_mouse_up", "*")
    def on_edje_signal_dialer_button_mouse_up(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        key = self.button_labels[self.active][y][x]
        self.text.append(key)
        # The trailing whitespace is a workaround for the one char invisible
        # bug due to some problems with scaling of text parts.
        self.part_text_set("label", "".join(self.text)+" ")
        self.set_button_text(0)
        print "mouse up:", time.time()-now

    @edje.decorators.signal_callback("kb_button_mouse_down", "*")
    def on_edje_signal_dialer_button_mouse_down(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        num = 4*y+x+1
        if self.active == 0:
            self.set_button_text(num)
        print "mouse down:", time.time()-now

    @edje.decorators.signal_callback("kb_mutton_mouse_in", "*")
    def on_edje_signal_dialer_button_mouse_in(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        self.part_text_set("label_preview", self.button_labels[self.active][y][x])
        print "mouse in:", time.time()-now

    def set_button_text(self, num):
        for i in xrange(4):
            for j in xrange(4):
                self.part_text_set("label_%d_%d" % (i,j) , self.button_labels[num][j][i])
        self.active = num

        if num != 0:
            num = 1

        for i in xrange(4):
            for j in xrange(4):
                self.part_text_set("label2_%d_%d" % (i,j) , self.button_labels2[num][j][i])

#----------------------------------------------------------------------------#
class pyphone_pin(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "pin")
        self.part_text_set( "label_description", "SIM PIN?" )
        self.text = []

    @edje.decorators.signal_callback("pin_button_pressed", "*")
    def on_edje_signal_pin_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "done":
            if dbus_object.gsm_device_obj:
                try:
                    self.part_text_set( "label_description", "Sending..." )
                    dbus_object.gsm_sim_iface.SendAuthCode("".join(self.text))
                except DBusException, e:
                    try:
                        authstatus = dbus_object.gsm_sim_iface.GetAuthStatus()
                        if authstatus == "SIM PUK":
                            self.main.transition_to("puk")
                        elif authstatus == "SIM PIN":
                            self.part_text_set( "label_description", "Invalid. SIM PIN?" )
                    except DBusException, e:
                        print e
                else:
                    self.part_text_set("label", "")
                    dbus_object.gsm_device_iface.SetAntennaPower(True)
                    dbus_object.gsm_network_iface.Register()
                    self.main.transition_to("main")

#----------------------------------------------------------------------------#
class pyphone_puk(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "puk")
        self.part_text_set( "label_description", "SIM PUK?" )
        self.text = []
        self.puk = []

    @edje.decorators.signal_callback("pin_button_pressed", "*")
    def on_edje_signal_puk_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "done":
            if self.puk == []:
              self.part_text_set( "label_description", "New PIN?" )
              self.puk = self.text
              self.text = []
            elif dbus_object.gsm_device_obj:
                try:
                    self.part_text_set( "label_description", "Sending..." )
                    dbus_object.gsm_sim_iface.Unlock("".join(self.puk), "".join(self.text))
                except DBusException, e:
                    print e
                    self.part_text_set( "label_description", "Invalid. SIM PUK?" )
                else:
                    self.part_text_set("label", "")
                    self.text = []
                    self.puk = []
                    dbus_object.gsm_device_iface.SetAntennaPower(True)
                    dbus_object.gsm_network_iface.Register()
                    self.main.transition_to("main")

#----------------------------------------------------------------------------#
class pyphone_menu( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "menu" )
        self.buttons = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_*" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        if source == "target_cancel":
            self.deactivate()
            self.cb( "cancel" )
        else:
            id = int( source.split( "_", 1 )[1] )
            self.deactivate()
            self.cb( self.part_text_get( "target_label_%i" % id ) )

    def activate( self, buttons, cb ):
        self.buttons = buttons
        self.cb = cb
        count = len( buttons )
        assert count == 4
        self.part_text_set( "target_label_0", buttons[0] )
        self.part_text_set( "target_label_1", buttons[1] )
        self.part_text_set( "target_label_2", buttons[2] )
        self.part_text_set( "target_label_3", buttons[3] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )


#----------------------------------------------------------------------------#
class pyphone_lock( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "lock" )
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "target_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        if id == self.step+1: # correct button
            self.signal_emit( "activate_%i" % id, "" )
            self.step += 1
        else:
            for id in range( 1, 5 ):
                self.signal_emit( "deactivate_%i" % id, "" )
            self.step = 0
        if self.step == 4:
            self.signal_emit( "invisible", "" )

    def activate( self ):
        self.step = 0
        for id in range( 1, 5 ):
            self.signal_emit( "deactivate_%i" % id, "" )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class pyphone_error( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "error" )
        self.buttons = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        self.deactivate()
        self.cb( self.part_text_get( "label_%i" % id ) )

    def activate( self, description, buttons, cb ):
        self.buttons = buttons
        self.cb = cb
        count = len( buttons )
        assert 1 <= count <= 3
        self.part_text_set( "description", description )
        if count == 1:
            self.signal_emit( "hide_0", "" )
            self.part_text_set( "label_0", "" )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[0] )
            self.signal_emit( "hide_2", "" )
            self.part_text_set( "label_2", "" )
        elif count == 2:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "hide_1", "" )
            self.part_text_set( "label_1", "" )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[1] )
        elif count == 3:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[1] )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[2] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class GUI(object):
#----------------------------------------------------------------------------#
    def __init__( self, options, args ):

        edje.frametime_set(1.0 / options.fps)

        self.evas_canvas = EvasCanvas(
            fullscreen = options.fullscreen,
            engine = options.engine,
            size = options.geometry
        )

        self.groups = {}
        for part in ("swallow", "main", "power"):
            self.groups[part] = edje_group(self, part)
            self.evas_canvas.evas_obj.data[part] = self.groups[part]

        self.groups["sms"] = pyphone_sms(self)
        self.evas_canvas.evas_obj.data["sms"] = self.groups["sms"]
        self.groups["phone"] = pyphone_phone(self)
        self.evas_canvas.evas_obj.data["phone"] = self.groups["phone"]
        self.groups["call"] = pyphone_call(self)
        self.evas_canvas.evas_obj.data["call"] = self.groups["call"]
        self.groups["contacts"] = pyphone_contacts(self)
        self.evas_canvas.evas_obj.data["contacts"] = self.groups["contacts"]
        self.groups["pin"] = pyphone_pin(self)
        self.evas_canvas.evas_obj.data["pin"] = self.groups["pin"]
        self.groups["puk"] = pyphone_puk(self)
        self.evas_canvas.evas_obj.data["puk"] = self.groups["puk"]
        self.groups["menu"] = pyphone_menu(self)
        self.evas_canvas.evas_obj.data["menu"] = self.groups["menu"]
        self.groups["swallow"].part_swallow( "menu", self.groups["menu"] )
        self.groups["lock"] = pyphone_lock(self)
        self.evas_canvas.evas_obj.data["lock"] = self.groups["lock"]
        self.groups["swallow"].part_swallow( "lock", self.groups["lock"] )
        self.groups["error"] = pyphone_error(self)
        self.evas_canvas.evas_obj.data["error"] = self.groups["error"]
        self.groups["swallow"].part_swallow( "error", self.groups["error"] )

        self.groups["swallow"].show()
        self.groups["swallow"].on_key_down_add(self.on_key_down)

        self.groups["swallow"].part_text_set("label_top_left", "zhone!")

        self.groups["swallow"].message_send(1, 0.0) # GSM signal strength
        self.groups["swallow"].message_send(2, 0.0) # battery charge

        self.groups["swallow"].part_swallow("swallow2", self.groups["main"])
        self.current_group = self.groups["main"]
        self.previous_group = self.groups["phone"]
        self.in_transition = False
        ecore.timer_add(60.0, self.display_time)
        self.display_time()

        self.groups["swallow"].part_text_set( "label_top_right", "no dbus" )
        ecore.idle_enterer_add( self.dbus_objectInit )

    def run( self ):
        ecore.main_loop_begin()

    def shutdown( self ):
        ecore.main_loop_quit()

    def dbus_objectInit( self ):
        print "dbus_objectInit..."
        global dbus_object
        if dbus_object is None:
            dbus_object = DBusObject()
        if not dbus_object.initialize():
            # try again later
            ecore.timer_add( 10.0, self.dbus_objectInit )
            return False
        else:
            self.dbus_objectInitOK()
        return False

    def dbus_objectInitOK( self ):
        print "dbus_objectInitOK!"
        if dbus_object.usage_obj is not None:
            dbus_object.onResourceChanged.append(self.display_resources)
            self.display_resources()

        if dbus_object.gsm_device_obj is not None:
            dbus_object.onCallStatus.append( self.groups["call"].onCallStatus )
            dbus_object.onNetworkStatus.append(self.update_network)
            try:
                dbus_object.gsm_device_iface.SetAntennaPower(True)
                dbus_object.gsm_network_iface.Register()
            except DBusException, e:
                # TODO handle this better
                print e
                try:
                    authstatus = dbus_object.gsm_sim_iface.GetAuthStatus()
                    if authstatus == "SIM PUK":
                        self.transition_to("puk")
                    elif authstatus == "SIM PIN":
                        self.transition_to("pin")
                except DBusException, e:
                    print e

        if dbus_object.idlenotifier_iface is not None:
            dbus_object.onIdleStateChanged.append(self.lock_on_idle)

        if dbus_object.device_power_iface is not None:
            # Update Battery charge as soon as we have DBus
            batcharge = dbus_object.device_power_iface.GetEnergyPercentage()
            self.groups["swallow"].message_send(2, batcharge/100.0) # battery charge

        if options.start:
            self.transition_to(options.start)

    def lock_on_idle( self, state ):
        if state == "LOCK":
            self.groups["lock"].activate()

    def display_time(self):
        self.groups["main"].part_text_set("label", time.strftime("%H:%M", time.localtime()))
        self.groups["swallow"].part_text_set("label_top_center", time.strftime("%Y-%m-%d", time.localtime()))
        if ( dbus_object is not None ) and ( dbus_object.device_power_iface is not None ):
            batcharge = dbus_object.device_power_iface.GetEnergyPercentage()
            self.groups["swallow"].message_send(2, batcharge/100.0) # battery charge
        return True

    def display_resources( self, **args ):
        items = []
        names = {
            "GSM": "G",
            "WiFi": "W",
            "GPS": "S",
            "Bluetooth": "B",
        }
        for resourcename in dbus_object.usage_iface.ListResources():
            if dbus_object.usage_iface.GetResourceState( resourcename ):
                users = dbus_object.usage_iface.GetResourceUsers( resourcename )
                items.append( "%s%s" % ( names[resourcename], len( users ) ) )
            else:
                items.append( "%s" % ( names[resourcename].lower() ) )
            policy = dbus_object.usage_iface.GetResourcePolicy( resourcename )
            if policy == 'enabled':
                items[-1] = "+" + items[-1]
                continue
            elif policy == 'disabled':
                items[-1] = "-" + items[-1]
                continue
        self.groups["swallow"].part_text_set( "label_top_right", " ".join( items ) )

    def update_network( self, **args):
        status = args["status"]
        self.groups["swallow"].message_send(1, status["strength"]/100.0)
        if status["registration"] == "denied":
            self.groups["swallow"].part_text_set("label_top_left", "SOS only")
        elif status["registration"] == "unregistered":
            self.groups["swallow"].part_text_set("label_top_left", "No Service")
        elif status["registration"] == "busy":
            self.groups["swallow"].part_text_set("label_top_left", "Searching...")
        elif status["registration"] == "unknown":
            self.groups["swallow"].part_text_set("label_top_left", "[Unknown]")
        else:
            self.groups["swallow"].part_text_set("label_top_left", status["provider"])

    # TODO better state management for transitions
    def transition_to(self, target):
        if self.current_group == self.groups[target]:
            return
        print "transition to", target
        self.in_transition = True

        self.previous_group = self.current_group

        self.current_group = self.groups[target]
        self.current_group.signal_emit("visible", "")
        self.groups["swallow"].part_swallow("swallow1", self.current_group)
        self.previous_group.signal_emit("fadeout", "")

    def transition_finished(self):
        print "finished"
        self.previous_group.hide()
        self.groups["swallow"].part_swallow("swallow2", self.current_group)
        self.in_transition = False

    def on_key_down(self, obj, event):
        if event.keyname in ("F6", "f"):
            self.evas_canvas.evas_obj.fullscreen = not self.evas_canvas.evas_obj.fullscreen
        elif event.keyname == "Escape":
            ecore.main_loop_quit()


#----------------------------------------------------------------------------#
class EvasCanvas(object):
#----------------------------------------------------------------------------#
    def __init__(self, fullscreen, engine, size):
        if engine == "x11":
            f = ecore.evas.SoftwareX11
        elif engine == "x11-16":
            if ecore.evas.engine_type_supported_get("software_x11_16"):
                f = ecore.evas.SoftwareX11_16
            else:
                print "warning: x11-16 is not supported, fallback to x11"
                f = ecore.evas.SoftwareX11

        self.evas_obj = f(w=size[0], h=size[1])
        self.evas_obj.callback_delete_request = self.on_delete_request
        self.evas_obj.callback_resize = self.on_resize

        self.evas_obj.title = TITLE
        self.evas_obj.name_class = (WM_NAME, WM_CLASS)
        self.evas_obj.fullscreen = fullscreen
        self.evas_obj.size = size
        self.evas_obj.evas.image_cache_set( 6*1024*1024 )
        self.evas_obj.evas.font_cache_set( 2*1024*1024 )
        self.evas_obj.show()

    def on_resize(self, evas_obj):
        x, y, w, h = evas_obj.evas.viewport
        size = (w, h)
        for key in evas_obj.data.keys():
            evas_obj.data[key].size = size

    def on_delete_request(self, evas_obj):
        ecore.main_loop_quit()

#----------------------------------------------------------------------------#
class MyOptionParser(OptionParser):
#----------------------------------------------------------------------------#
    def __init__(self):
        OptionParser.__init__(self)
        self.set_defaults(fullscreen = False)
        self.add_option("-e",
                      "--engine",
                      type="choice",
                      choices=("x11", "x11-16"),
                      default="x11-16",
                      help=("which display engine to use (x11, x11-16), "
                            "default=%default"))
        self.add_option("--fullscreen",
                      action="store_true",
                      dest="fullscreen",
                      help="launch in fullscreen")
        self.add_option("--no-fullscreen",
                      action="store_false",
                      dest="fullscreen",
                      help="launch in a window")
        self.add_option("-g",
                      "--geometry",
                      type="string",
                      metavar="WxH",
                      action="callback",
                      callback=self.parse_geometry,
                      default=(WIDTH, HEIGHT),
                      help="use given window geometry")
        self.add_option("-f",
                      "--fps",
                      type="int",
                      default=20,
                      help="frames per second to use, default=%default")
        self.add_option("-s",
                      "--start",
                      type="string",
                      default=None,
                      help="start with the given page")

    def parse_geometry(option, opt, value, parser):
        try:
            w, h = value.split("x")
            w = int(w)
            h = int(h)
        except Exception, e:
            raise optparse.OptionValueError("Invalid format for %s" % option)
        parser.values.geometry = (w, h)

#----------------------------------------------------------------------------#
class DBusObject( object ):
#----------------------------------------------------------------------------#
    def __init__( self ):
        self.objects = {}
        self.onResourceChanged = []
        self.onCallStatus = []
        self.onNetworkStatus = []
        self.onIdleStateChanged = []
        self.ignoreSuspend = False

        self.framework_obj = None
        self.gsm_device_obj = None
        self.gsm_device_iface = None
        self.usage_iface = None
        self.device_iface = None
        self.device_power_iface = None
        self.idlenotifier_obj = None
        self.idlenotifier_iface = None
        self.inputnotifier_obj = None
        self.inputnotifier_iface = None
        self.display_obj = None
        self.display_iface = None

        self.fullinit = False

    def tryGetProxy( self, busname, objname ):
        object = None
        try:
            object = self.objects[ "%s:%s" % ( busname, objname ) ]
        except KeyError:
            try:
                object = self.bus.get_object( busname, objname )
            except DBusException, e:
                print "could not create proxy for %s:%s" % ( busname, objname ), e
            else:
                self.objects[ "%s:%s" % ( busname, objname ) ] = object
        return object

    def initialize( self ):
        if self.fullinit:
            return True
        try:
            self.bus = SystemBus( mainloop=e_dbus.DBusEcoreMainLoop() )
        except DBusException, e:
            print "could not connect to dbus_object system bus:", e
            return False

        # Framework
        fw_obj = self.tryGetProxy( 'org.freesmartphone.frameworkd', '/org/freesmartphone/Framework' )
        if fw_obj is None:
            print ( "could not connect to org.freesmartphone.frameworkd -- is the framework daemon started?" )
            return False
        else:
            self.fw = Interface( fw_obj, "org.freesmartphone.Objects" )
        failcount = 0

        # Usage
        self.usage_obj = self.tryGetProxy( 'org.freesmartphone.ousaged', '/org/freesmartphone/Usage' )
        if ( self.usage_obj is not None ) and ( self.usage_iface is None ):
            self.usage_iface = Interface(self.usage_obj, 'org.freesmartphone.Usage')
            self.usage_iface.connect_to_signal( "ResourceChanged", self.cbResourceChanged )
            self.usage_iface.RequestResource("GSM")
        if self.usage_obj is None:
            failcount += 1
        else:
            print "usage ok", self.usage_iface

        # Phone
        self.gsm_device_obj = self.tryGetProxy( 'org.freesmartphone.ogsmd', '/org/freesmartphone/GSM/Device' )
        print self.gsm_device_obj

        if ( self.gsm_device_obj is not None ) and ( self.gsm_device_iface is None ):
            print "creating gsm interfaces"
            self.gsm_device_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Device')
            self.gsm_sim_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.SIM')
            self.gsm_network_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Network')
            self.gsm_call_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Call')
            self.gsm_test_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Test')
            self.gsm_call_iface.connect_to_signal( "CallStatus", self.cbCallStatus )
            self.gsm_network_iface.connect_to_signal( "Status", self.cbNetworkStatus )
        if self.gsm_device_obj is None:
            failcount += 1
        else:
            print "gsm ok", self.gsm_network_iface

        self.device_obj = self.tryGetProxy( 'org.freesmartphone.odeviced', '/org/freesmartphone/Device' )
        if ( self.device_obj is not None ) and ( self.device_iface is None ):
            self.device_iface = Interface( self.device_obj, 'org.freesmartphone.Device' )

            self.device_power_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.PowerSupply" )[0] )
            self.device_power_iface = Interface(self.device_power_obj, 'org.freesmartphone.Device.PowerSupply')

            self.idlenotifier_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.IdleNotifier" )[0] )

            self.idlenotifier_iface = Interface( self.idlenotifier_obj, "org.freesmartphone.Device.IdleNotifier" )
            self.idlenotifier_iface.connect_to_signal( "State", self.cbIdleStateChanged )

            self.inputnotifier_obj = self.bus.get_object( "org.freesmartphone.odeviced", "/org/freesmartphone/Device/Input" )
            self.inputnotifier_iface = Interface( self.inputnotifier_obj, "org.freesmartphone.Device.Input" )
            self.inputnotifier_iface.connect_to_signal( "Event", self.cbEvent )

            print "displays:", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.Display" )
            self.display_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.Display" )[0] )
            if self.display_obj is not None:
                self.display_iface = Interface( self.display_obj, "org.freesmartphone.Device.Display" )
                self.display_iface.SetBrightness( 90 )
        if self.device_obj is None:
            failcount += 1
        else:
            print "device ok", self.device_iface

        print "failcount=", failcount
        if failcount == 0:
            self.fullinit = True
        return self.fullinit

    def cbResourceChanged( self, resourcename ):
        for cb in self.onResourceChanged:
            cb( resourcename=resourcename )

    def cbCallStatus( self, id, status, properties ):
        print "CALL STATUS=", id, status, properties
        if self.idlenotifier_iface is not None:
            self.idlenotifier_iface.SetState("BUSY")
        for cb in self.onCallStatus:
            cb( id=id, status=status, properties=properties )

    def cbNetworkStatus( self, status ):
        for cb in self.onNetworkStatus:
            cb( status=status )

    def cbIdleStateChanged( self, state ):
        print "IDLE STATE=", state
        for cb in self.onIdleStateChanged:
            cb( state=state )
        if state == "BUSY":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 90 )
        elif state == "IDLE_DIM":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 20 )
        elif state == "IDLE_PRELOCK":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 0 )

    def cbEvent( self, name, action, seconds ):
        print "INPUT EVENT=", name, action, seconds
        if name+action == "AUXpressed":
            # FIXME launch transition to main screen
            pass
        elif name+action == "POWERpressed":
            # FIXME should the kernel filter out the button event that triggerd the wakeup?
            if self.ignoreSuspend: # we've just resumed
                self.ignoreSuspend = False
                return
            self.ignoreSuspend = True
            self.gsm_device_iface.PrepareForSuspend()
            print "ENTERING SUSPEND"
            os.system( "apm -s" )
            print "RETURN FROM SUSPEND"
            self.gsm_device_iface.RecoverFromSuspend()
            self.idlenotifier_iface.SetState("BUSY")

if __name__ == "__main__":

    options, args = MyOptionParser().parse_args()
    dbus_object = None
    gui = GUI( options, args )
    try:
        gui.run()
    except KeyboardInterrupt:
        gui.shutdown()
        del gui
