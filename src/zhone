#!/usr/bin/python
#coding=utf8

WIDTH = 480
HEIGHT = 640

TITLE = "zhone"
WM_NAME = "zhone"
WM_CLASS = "zhone"

import os
import sys
import e_dbus
import evas
import evas.decorators
import edje
import edje.decorators
import ecore
import ecore.evas
from dbus import SystemBus, Interface
from optparse import OptionParser
import time

for i in "../data/themes/zhone.edj /usr/local/share/zhone/zhone.edj /usr/share/zhone/zhone.edj".split():
    if os.path.exists( i ):
       global edjepath
       edjepath = i
       break
else:
    raise "Edje not found"

class edje_group(edje.Edje):
    def __init__(self, main, group):
        self.main = main
        global edjepath
        f = edjepath
        try:
            edje.Edje.__init__(self, self.main.evas_canvas.evas_obj.evas, file=f, group=group)
        except edje.EdjeLoadError, e:
            raise SystemExit("error loading %s: %s" % (f, e))
        self.size = self.main.evas_canvas.evas_obj.evas.size

    @edje.decorators.signal_callback("transition:*", "*")
    def on_edje_signal_transition(self, emission, source):
        # TODO better state management
        if not self.main.in_transition:
            target = emission.split(':')[1]
            if target == "phone" and not self.main.groups["call"].state == "idle":
                target = "call"
            self.main.in_transition = True
            self.main.transition_to(target)

    @edje.decorators.signal_callback("finished_transition", "*")
    def on_edje_signal_finished_transition(self, emission, source):
        self.main.transition_finished()
        self.main.in_transition = False

class pyphone_main(edje_group):
    def __init__(self, main):
        edje_group.__init__(self, main, "main")

class pyphone_phone(edje_group):
    def __init__(self, main):
        edje_group.__init__(self, main, "phone")
        self.text = []

    @edje.decorators.signal_callback("dialer_button_pressed", "*")
    def on_edje_signal_dialer_button_pressed(self, emission, source):
        if "button_" in source:
            key = source.split("_", 1)[1]
            if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "#"):
                self.text.append(key)
                # The trailing whitespace is a workaround for the one char invisible
                # bug due to some problems with scaling of text parts.
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "star":
                self.text.append("*")
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "delete":
                self.text = self.text[:-1]
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "dial":
                if not self.main.in_transition:
                    self.main.groups["call"].update_state("calling")
                    self.main.in_transition = True
                    self.main.transition_to("call")
        else:
            key = source
        #self.text.append(source)
        #self.part_text_set("label", "".join(self.text))

class pyphone_call(edje_group):
    def __init__(self, main):
        edje_group.__init__(self, main, "call")
        self.update_state("idle")

    @edje.decorators.signal_callback("call_button_pressed", "button_left")
    def on_edje_signal_call_button_left_pressed(self, emission, source):
        if self.state == "ringing":
            self.update_state("talking")

    @edje.decorators.signal_callback("call_button_pressed", "button_right")
    def on_edje_signal_call_button_right_pressed(self, emission, source):
        if self.state == "calling":
            self.update_state("idle")
        elif self.state == "talking":
            self.update_state("idle")
        elif self.state == "ringing":
            self.update_state("idle")

    def update_state(self, state):
        self.state = state
        self.part_text_set( "label_description", state )
        if state == "calling":
            self.part_text_set( "label_left", "" )
            self.part_text_set( "label_right", "cancel" )
        elif state == "talking":
            self.part_text_set( "label_left", "" )
            self.part_text_set( "label_right", "hangup" )
        elif state == "ringing":
            self.part_text_set( "label_left", "answer" )
            self.part_text_set( "label_right", "reject" )
        elif state == "idle":
            self.part_text_set( "label_left", "" )
            self.part_text_set( "label_right", "" )

class pyphone_sms(edje_group):
    def __init__(self, main):
        edje_group.__init__(self, main, "sms")
        self.text = []
        self.button_labels2 = [
            [
                [".,?!", "abc", "def", ""],
                ["ghi", "jkl", "mno", ""],
                ["pqrs", "tuv", "wxyz", ""],
                ["", "", "⇦⇧⇨", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.button_labels = [
            [
                ["1", "2", "3", "↤"],
                ["4", "5", "6", "↲"],
                ["7", "8", "9", "Abc"],
                ["+", "0", "⇩", "+"],
            ],
            [
                ["1", "?", "", ""],
                [".", ",", "", ""],
                ["!", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "2", "c", ""],
                ["", "a", "b", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "3", "f"],
                ["", "", "d", "e"],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", "↤"],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["4", "i", "", ""],
                ["g", "h", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "5", "l", ""],
                ["", "j", "k", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "6", "o"],
                ["", "", "m", "n"],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "s", "", ""],
                ["7", "r", "", ""],
                ["p", "q", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "8", "v", ""],
                ["", "t", "u", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", "z"],
                ["", "", "9", "y"],
                ["", "", "w", "x"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", " ", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "⇧", ""],
                ["", "⇦", "⇩", "⇨"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.set_button_text(0)
        self.active = 0

    @edje.decorators.signal_callback("kb_button_mouse_up", "*")
    def on_edje_signal_dialer_button_mouse_up(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        key = self.button_labels[self.active][y][x]
        self.text.append(key)
        # The trailing whitespace is a workaround for the one char invisible
        # bug due to some problems with scaling of text parts.
        self.part_text_set("label", "".join(self.text)+" ")
        self.set_button_text(0)
        print "mouse up:", time.time()-now

    @edje.decorators.signal_callback("kb_button_mouse_down", "*")
    def on_edje_signal_dialer_button_mouse_down(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        num = 4*y+x+1
        if self.active == 0:
            self.set_button_text(num)
        print "mouse down:", time.time()-now

    @edje.decorators.signal_callback("kb_mutton_mouse_in", "*")
    def on_edje_signal_dialer_button_mouse_in(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        self.part_text_set("label_preview", self.button_labels[self.active][y][x])
        print "mouse in:", time.time()-now

    def set_button_text(self, num):
        for i in xrange(4):
            for j in xrange(4):
                self.part_text_set("label_%d_%d" % (i,j) , self.button_labels[num][j][i])
        self.active = num

        if num != 0:
            num = 1

        for i in xrange(4):
            for j in xrange(4):
                self.part_text_set("label2_%d_%d" % (i,j) , self.button_labels2[num][j][i])

class GUI(object):
    def on_key_down(self, obj, event):
        if event.keyname in ("F6", "f"):
            self.evas_canvas.evas_obj.fullscreen = not self.evas_canvas.evas_obj.fullscreen
        elif event.keyname == "Escape":
            ecore.main_loop_quit()

    def __init__(self):
        edje.frametime_set(1.0 / options.fps)

        self.evas_canvas = EvasCanvas(
            fullscreen = options.fullscreen,
            engine = options.engine,
            size = options.geometry
        )

        self.groups = {}
        for part in ("swallow", "main", "contacts", "power", "call"):
            self.groups[part] = edje_group(self, part)
            self.evas_canvas.evas_obj.data[part] = self.groups[part]

        self.groups["sms"] = pyphone_sms(self)
        self.evas_canvas.evas_obj.data["sms"] = self.groups["sms"]
        self.groups["phone"] = pyphone_phone(self)
        self.evas_canvas.evas_obj.data["phone"] = self.groups["phone"]
        self.groups["call"] = pyphone_call(self)
        self.evas_canvas.evas_obj.data["call"] = self.groups["call"]

        self.groups["swallow"].show()
        self.groups["swallow"].on_key_down_add(self.on_key_down)

        self.groups["swallow"].part_text_set("label_top_left", "zhone!");

        self.groups["swallow"].part_swallow("swallow2", self.groups["main"])
        self.current_group = self.groups["main"]
        self.previous_group = self.groups["phone"]
        self.in_transition = False
        ecore.timer_add(60.0, self.display_time)
        self.display_time()

        if dbus:
            dbus.onResourceChanged.append(self.display_resources)
            self.display_resources()
        else:
            self.groups["swallow"].part_text_set( "label_top_right", "no dbus" );

    def display_time(self):
        self.groups["main"].part_text_set("label", time.strftime("%H:%M", time.localtime()));
        self.groups["swallow"].part_text_set("label_top_center", time.strftime("%Y-%m-%d", time.localtime()));
        return True;

    def display_resources( self, **args ):
        items = []
        names = {
            "GSM": "G",
            "WiFi": "W",
            "GPS": "S",
            "Bluetooth": "B",
        }
        for resourcename in dbus.usage_iface.ListResources():
            if dbus.usage_iface.GetResourceState( resourcename ):
                users = dbus.usage_iface.GetResourceUsers( resourcename )
                items.append( "%s%s" % ( names[resourcename], len( users ) ) )
            else:
                items.append( "%s" % ( names[resourcename].lower() ) )
            policy = dbus.usage_iface.GetResourcePolicy( resourcename )
            if policy == 'enabled':
                items[-1] = "+" + items[-1]
                continue
            elif policy == 'disabled':
                items[-1] = "-" + items[-1]
                continue
        self.groups["swallow"].part_text_set( "label_top_right", " ".join( items ) );

    def transition_to(self, target):
        print "transition to", target

        self.previous_group = self.current_group

        self.current_group = self.groups[target]
        self.current_group.signal_emit("visible", "")
        self.groups["swallow"].part_swallow("swallow1", self.current_group)
        self.previous_group.signal_emit("fadeout", "")

    def transition_finished(self):
        print "finished"
        self.previous_group.hide()
        self.groups["swallow"].part_swallow("swallow2", self.current_group)


class EvasCanvas(object):
    def __init__(self, fullscreen, engine, size):
        if engine == "x11":
            f = ecore.evas.SoftwareX11
        elif engine == "x11-16":
            if ecore.evas.engine_type_supported_get("software_x11_16"):
                f = ecore.evas.SoftwareX11_16
            else:
                print "warning: x11-16 is not supported, fallback to x11"
                f = ecore.evas.SoftwareX11

        self.evas_obj = f(w=size[0], h=size[1])
        self.evas_obj.callback_delete_request = self.on_delete_request
        self.evas_obj.callback_resize = self.on_resize

        self.evas_obj.title = TITLE
        self.evas_obj.name_class = (WM_NAME, WM_CLASS)
        self.evas_obj.fullscreen = fullscreen
        self.evas_obj.size = size
        self.evas_obj.show()

    def on_resize(self, evas_obj):
        x, y, w, h = evas_obj.evas.viewport
        size = (w, h)
        for key in evas_obj.data.keys():
            evas_obj.data[key].size = size

    def on_delete_request(self, evas_obj):
        ecore.main_loop_quit()

class MyOptionParser(OptionParser):
    def __init__(self):
        OptionParser.__init__(self)
        self.set_defaults(fullscreen = False)
        self.add_option("-e",
                      "--engine",
                      type="choice",
                      choices=("x11", "x11-16"),
                      default="x11-16",
                      help=("which display engine to use (x11, x11-16), "
                            "default=%default"))
        self.add_option("--fullscreen",
                      action="store_true",
                      dest="fullscreen",
                      help="launch in fullscreen")
        self.add_option("--no-fullscreen",
                      action="store_false",
                      dest="fullscreen",
                      help="launch in a window")
        self.add_option("-g",
                      "--geometry",
                      type="string",
                      metavar="WxH",
                      action="callback",
                      callback=self.parse_geometry,
                      default=(WIDTH, HEIGHT),
                      help="use given window geometry")
        self.add_option("-f",
                      "--fps",
                      type="int",
                      default=20,
                      help="frames per second to use, default=%default")

    def parse_geometry(option, opt, value, parser):
        try:
            w, h = value.split("x")
            w = int(w)
            h = int(h)
        except Exception, e:
            raise optparse.OptionValueError("Invalid format for %s" % option)
        parser.values.geometry = (w, h)

class DBus( object ):
    def __init__( self ):
        try:
            self.bus = SystemBus( mainloop=e_dbus.DBusEcoreMainLoop())
            self.usage_obj = self.bus.get_object('org.freesmartphone.Usage', '/org/freesmartphone/Usage')
            self.usage_iface = Interface(self.usage_obj, 'org.freesmartphone.Usage')
        except Exception, e:
            print e
            raise SystemExit

        self.onResourceChanged = []

        #connect functions to dbus events
        for cb in ( self.ResourceChanged, ):
            self.usage_obj.connect_to_signal( cb.__name__, cb )

    def ResourceChanged( self, resourcename ):
        for cb in self.onResourceChanged:
            cb( resourcename=resourcename )

if __name__ == "__main__":
    options, args = MyOptionParser().parse_args()
    dbus = DBus()
#    dbus = None
    gui = GUI()
    ecore.main_loop_begin()

