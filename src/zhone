#!/usr/bin/env python
#coding=utf8
"""
Zen Phone - A Phone UI

(C) 2007 Johannes 'Josch' Schauer
(C) 2008 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
(C) 2008 Jan 'Shoragan' Luebbe
(C) 2008 Daniel 'Alphaone' Willmann
(C) 2008 Openmoko, Inc.
GPLv2 or later

Warning: Please don't let yourself be inspired too much by this software,
it's lacking proper design, modularity, and stability. We did this as a
quick hack to demonstrate the feasibility of our dbus service level
framework. A proper redesign would be in order, but alas the framework
team has no resources to do that.

You have been warned :)

"""

import logging
logger = logging.getLogger( "zhone" )
logging.basicConfig( level    = logging.DEBUG,
                    format   = '%(asctime)s %(levelname)s %(message)s',
                    filename = '/tmp/zhone.log',
                    filemode = 'w' )
logger.addHandler( logging.StreamHandler() )
logger.setLevel( logging.DEBUG )

def log_dbus_error( e, desc ):
    logger.error( "%s (%s %s: %s)" % ( desc, e.__class__.__name__, e.get_dbus_name(), e.get_dbus_message() ) )

def handle_dbus_error( desc ):
    return lambda e: log_dbus_error( e, desc = desc )

def textblock_escape( text ):
    text = text.replace('&', '&amp;')
    text = text.replace('<', '&lt;')
    text = text.replace('>', '&gt;')
    return text

#----------------------------------------------------------------------------#
WIDTH = 480
HEIGHT = 640

TITLE = "zhone"
WM_NAME = "zhone"
WM_CLASS = "zhone"

#----------------------------------------------------------------------------#
import os
import sys
import e_dbus
import evas
import evas.decorators
import edje
import edje.decorators
import ecore
import ecore.evas
import cairo
from dbus import SystemBus, Interface
from dbus.exceptions import DBusException
from optparse import OptionParser
import time
import math

illume = None
try:
    import illume
except ImportError:
    logger.warning( "could not load illume interface module" )

#----------------------------------------------------------------------------#

edjepaths = "./zhone.edj ../data/themes/zhone.edj ../share/zhone.edj /usr/local/share/zhone/zhone.edj /usr/share/zhone/zhone.edj".split()

for i in edjepaths:
    if os.path.exists( i ):
       global edjepath
       edjepath = i
       break
else:
    raise Exception( "zhone.edj not found. looked in %s" % edjepaths )

#----------------------------------------------------------------------------#
class edje_group(edje.Edje):
#----------------------------------------------------------------------------#
    def __init__(self, main, group, parent_name="main"):
        self.main = main
        self.parent_name = parent_name
        self.group = group
        global edjepath
        f = edjepath
        try:
            edje.Edje.__init__(self, self.main.evas_canvas.evas_obj.evas, file=f, group=group)
        except edje.EdjeLoadError, e:
            raise SystemExit("error loading %s: %s" % (f, e))
        self.size = self.main.evas_canvas.evas_obj.evas.size

    def onShow( self ):
        pass

    def onHide( self ):
        pass

    @edje.decorators.signal_callback("mouse,clicked,1", "button_bottom_right")
    def on_edje_signal_button_bottom_right_pressed(self, emission, source):
        self.main.transition_to(self.parent_name)

    @edje.decorators.signal_callback("mouse,clicked,1", "button_bottom_left")
    def on_edje_signal_button_bottom_left_pressed(self, emission, source):
        self.main.groups["main_menu"].activate( self.group )
        self.main.transition_to("main_menu")

#----------------------------------------------------------------------------#
class pyphone_main(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "main")
        self.targets = {
            "phone": False,
            "contacts": False,
            "sms": False,
            "date": False,
            "location": False,
            "configuration": True,
        }
        self.update()

    def update( self ):
        for key, value in self.targets.items():
            if value:
                self.signal_emit( "activate_target_icon_%s" % key, "" )
            else:
                self.signal_emit( "deactivate_target_icon_%s" % key, "" )

    @edje.decorators.signal_callback("mouse,clicked,1", "target_*")
    def on_edje_signal_button_pressed(self, emission, source):
        target = source.split('_', 1)[1]
        if not self.targets[target]:
            return
        if target == "phone" and not self.main.groups["call"].status in ["idle" , "release"]:
            target = "call"
        self.main.transition_to(target)

#----------------------------------------------------------------------------#
class pyphone_phone(edje_group):
#----------------------------------------------------------------------------#
    TIMEOUT = 2.0
    def __init__(self, main):
        edje_group.__init__(self, main, "phone")
        self.text = []
        self.last = 0.0

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_dialer_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", u"".join(self.text)+u" ")
        elif key in "star":
            if self.text and ( time.time()-self.last < self.TIMEOUT ):
                if self.text[-1] == "*":
                    del self.text[-1]
                    self.text.append( "+" )
                elif self.text[-1] == "+":
                    del self.text[-1]
                    self.text.append( "*" )
                else:
                    self.text.append( "*" )
            else:
                self.text.append("*")
            self.part_text_set( "label", u"".join(self.text)+u" " )
        elif key in "hash":
            self.text += "#"
            self.part_text_set( "label", u"".join(self.text)+u" " )
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", u"".join(self.text)+u" ")
        elif key in "dial":
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Initiate( "".join(self.text), "voice" )
            else:
                # Fake onCallStatus...
                self.main.groups["call"].onCallStatus( None, "outgoing", {"peer": "".join(self.text)} )
        self.last = time.time()

    def onNetworkStatus( self, status ):
        logger.info( "network status changed: %s" % status )
        #if(status.has_key("registration") != "busy")  # XXX this might work too.  which is better?
        if(status.has_key('provider')):
            self.main.agents["gsm"].setState("Registered: %s" % status['provider'])
            self.main.groups["main"].targets["phone"] = True
            self.main.groups["main"].update()
            if dbus_object.gsm_sim_iface.GetSimReady():
                self.main.groups["contacts"].prepare()
                self.main.groups["sms"].prepare()
        else:
            self.main.agents["gsm"].setState("Failed to register to network")
            self.main.groups["main"].targets["phone"] = False
            self.main.groups["main"].update()

#----------------------------------------------------------------------------#
class pyphone_call(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "call")
        self.update_status("idle")
        self.call = None

    def onCallStatus( self, id, status, properties ):
        self.call = id
        self.update_status(status)
        try:
            self.part_text_set( "label", properties[ "peer" ] )
        except KeyError:
            pass

    @edje.decorators.signal_callback("call_button_pressed", "button_left")
    def on_edje_signal_call_button_left_pressed(self, emission, source):
        if self.status == "active":
            if dbus_object.gsm_device_obj:
                #dbus_object.gsm_call_iface.Hold(self.call)
                pass
            else:
                self.update_status("held")
        elif self.status in ["incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Activate(self.call)
            else:
                self.update_status("active")

    @edje.decorators.signal_callback("call_button_pressed", "button_right")
    def on_edje_signal_call_button_right_pressed(self, emission, source):
        if self.status in ["outgoing", "active", "incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Release(self.call)
            else:
                self.update_status("release")

    def update_status(self, status):
        self.part_text_set( "label_description", status )
        if status == "outgoing":
            self.part_text_set( "label_left", u"" )
            self.part_text_set( "label_right", u"cancel" )
        elif status == "active":
            self.part_text_set( "label_left", u"hold" )
            self.part_text_set( "label_right", u"hangup" )
        elif status == "incoming":
            self.part_text_set( "label_left", u"answer" )
            self.part_text_set( "label_right", u"reject" )
        elif status == "held":
            self.part_text_set( "label_left", u"resume" )
            self.part_text_set( "label_right", u"hangup" )
        else:
            self.part_text_set( "label_left", u"" )
            self.part_text_set( "label_right", u"" )
        if status in ["incoming", "outgoing"] and not self.status == status:
            # TODO make sure we get displayed
            self.main.transition_to("call")
        self.status = status

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.main.transition_to("dtmf")

#----------------------------------------------------------------------------#
class pyphone_dtmf(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "dtmf")
        self.text = []
        self.last = 0.0

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_dialer_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "star":
            if self.text and ( time.time()-self.last < self.TIMEOUT ):
                if self.text[-1] == "*":
                    del self.text[-1]
                    self.text.append( "+" )
                elif self.text[-1] == "+":
                    del self.text[-1]
                    self.text.append( "*" )
                else:
                    self.text.append( "*" )
            else:
                self.text.append("*")
            self.part_text_set( "label", "".join(self.text)+" " )
        elif key in "hash":
            self.text += "#"
            self.part_text_set( "label", "".join(self.text)+" " )
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "dial":
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.SendDtmf( "".join(self.text))
                self.main.transition_to("call")

    @edje.decorators.signal_callback("call_button_pressed", "button_right")
    def on_edje_signal_call_button_right_pressed(self, emission, source):
        self.main.transition_to("call")

#----------------------------------------------------------------------------#
class pyphone_sms(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "sms")
        self.ready = False
        self.busy = False
        self.messagebook = []
        self.current = []
        self.page = 0
        self.selected = None
        self.newindex = None
        self.senderTimer = ecore.timer_add( 60, self.processUnsentMessages )

    def processUnsentMessages( self ):
        if not dbus_object.gsm_device_obj:
            return True

        logger.info( "checking for unsent messages" )
        dbus_object.gsm_sim_iface.RetrieveMessagebook( "unsent", reply_handler=self.cbReceiveUnsentReply, error_handler=self.cbReceiveUnsentError )

        return True # call me again

    def cbReceiveUnsentReply( self, messages ):
        for message in messages:
            index, status, number, content, features = message
            logger.info( "trying to send message w/ index %d..." % index )
            dbus_object.gsm_sim_iface.SendStoredMessage( index, reply_handler=self.cbSendReply, error_handler=self.cbSendError )

    def cbReceiveUnsentError( self, e ):
        logger.info( "did not receive any unsent messages: %s" % e )

    def cbSendReply( self, reference ):
        logger.info( "sent message successfully w/ reference number %d" % reference )

    def cbSendError( self, e ):
        logger.error( "could not send message. leaving in outgoing. error was: %s" % e )

    def cbStoreReply( self, result ):
        logger.info( "stored message lives at SIM position %d" % result )
        self.processUnsentMessages()
        if not self.busy:
            dbus_object.gsm_sim_iface.RetrieveMessagebook(
                "all",
                reply_handler=self.cbMessagebookReply,
                error_handler=self.cbMessagebookError
            )
            self.busy = True

    def cbStoreError( self, e ):
        logger.warning( "error while storing message" )

    def cbSend1( self, selected, cb_data ):
        self.main.groups["text_edit"].setup(
            "sms",
            "", # text
            selected[0], # title
            selected[1], # reference
            self.cbSend2
        )

    def cbSend2( self, text, number ):
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreMessage(
                number, text, {},
                reply_handler=self.cbStoreReply,
                error_handler=self.cbStoreError
            )

    def cbDelete( self, result, reference ):
        if result == "abort":
            return
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.DeleteMessage(
                reference
            )
        for i in range( len( self.messagebook ) ):
            if self.messagebook[i][0] == reference:
                del self.messagebook[i]
                break
        self.updateList()

    def cbForward( self, selected, text ):
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreMessage(
                selected[1], text, {},
                reply_handler=self.cbStoreReply,
                error_handler=self.cbStoreError
            )

    def cbReply( self, text, number):
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreMessage(
                number, text, {},
                reply_handler=self.cbStoreReply,
                error_handler=self.cbStoreError
            )

    def cbMenu( self, result ):
        if result == "send":
            self.main.groups["contacts"].prepare()
            if self.main.groups["contacts"].ready:
                self.main.groups["list_choose"].setup(
                    "sms",
                    [ (x[1], x[2]) for x in  self.main.groups["contacts"].phonebook],
                    None,
                    self.cbSend1
                )
        elif result == "delete":
            self.main.groups["error"].activate(
                "delete?",
                ("abort", "delete"),
                self.current[self.selected][0], # reference
                self.cbDelete
            )
        elif result == "forward":
            self.main.groups["contacts"].prepare()
            if self.main.groups["contacts"].ready:
                self.main.groups["list_choose"].setup(
                    "sms",
                    [ (x[1], x[2] ) for x in  self.main.groups["contacts"].phonebook],
                    self.current[self.selected][3],
                    self.cbForward
                )
        elif result == "reply":
            self.main.groups["text_edit"].setup(
                "sms",
                "", # text
                self.current[self.selected][2], # title = number
                self.current[self.selected][2], # reference = number
                self.cbReply
            )

    def cbMessagebookReply( self, result ):
        logger.info( "retrieved messagebook: %s" % result )
        self.busy = False
        self.messagebook = result
        self.ready = True
        self.updateList()
        self.main.groups["main"].targets["sms"] = True
        self.main.groups["main"].update()
        if not self.newindex is None:
            message = [x for x in self.messagebook if x[0] == self.newindex]
            self.newindex = None
            if message and self.main.current_group == self.main.groups["main"]:
                message = message[0]
                if "read" in message[1]:
                    from_to = "From"
                    timestamp = message[4]["timestamp"]
                else:
                    from_to = "To"
                    timestamp = "Unknown"
                from_text = self.main.groups["contacts"].tryNumberToName( message[2] )
                self.main.groups["text_show"].setup(
                    "sms",
                    "%s: %s<br>Date: %s<p>%s" % (
                        from_to,
                        from_text,
                        timestamp,
                        textblock_escape( message[3] ).replace( '\n', '<br>' )
                    )
                )

    def cbMessagebookError( self, e ):
        logger.warning( "error while retrieving messagebook" )
        self.busy = False

    def onIncomingMessage( self, index ):
        logger.info( "new message! Retrieving messagebook..." )
        self.newindex = index
        if not self.busy:
            dbus_object.gsm_sim_iface.RetrieveMessagebook(
                "all",
                reply_handler=self.cbMessagebookReply,
                error_handler=self.cbMessagebookError
            )
            self.busy = True

    def prepare( self ):
        if not self.ready and not self.busy:
            if dbus_object.gsm_device_obj:
                logger.info( "retrieving messagebook..." )
                dbus_object.gsm_sim_iface.RetrieveMessagebook(
                    "all",
                    reply_handler=self.cbMessagebookReply,
                    error_handler=self.cbMessagebookError
                )
                self.busy = True
            else:
                # Fake messagebook...
                self.cbMessagebookReply( [
                    (0, "read", "+4544555", "Hello World!"),
                    (1, "read", "+456663443", "Zhone!"),
                    (2, "read", "+456663443", "Hi Guy\nGuess what, I now "+
                        "know to write multi-line SMSs.\nIsn't that "+
                        "nice?\n\nSome Buddy"),
                    (3, "read", "Flash SMS", "An SMS without digits. Strange, isn't it?"),
                ] )

    def onReadyStatus( self, status ):
        logger.debug( "SIM is ready: %s" % status )
        if status:
            # Force update
            self.ready = False
            self.prepare()

    def onShow( self ):
        self.prepare()
        self.updateList()

    def updateList( self):
        self.main.groups["contacts"].prepare()
        self.pages = max( ( len( self.messagebook ) - 1 ) / 6 + 1, 1 )
        if self.page >= self.pages:
            self.page = self.pages - 1
        if self.page < 0:
            self.page = 0
        self.current = self.messagebook[self.page*6:(self.page+1)*6]
        text = u"".join( [u"□"]*self.page+[u"▣"]+[u"□"]*(self.pages-self.page-1) )
        self.part_text_set( "pager", text )
        for i in range( 0, len( self.current ) ):
            main_text = self.main.groups["contacts"].tryNumberToName( self.current[i][2] )
            self.part_text_set( "label_main_list_%i" % i, main_text )
            sub_text = " ".join(self.current[i][3].splitlines())
            self.part_text_set( "label_sub_list_%i" % i, u"(%s) %s" % ( self.current[i][1], sub_text ) )
        for i in range( len( self.current ), 6):
            self.part_text_set( "label_main_list_%i" % i, u"" )
            self.part_text_set( "label_sub_list_%i" % i, u"" )
        self.selected = None
        for i in range( 6 ):
            self.signal_emit( "deactivate_target_list_%i" % i, "" )


    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if self.selected == id:
            return
        if self.selected is not None:
            self.signal_emit( "deactivate_target_list_%i" % self.selected, "" )
        self.signal_emit( "activate_target_list_%i" % id, "" )
        self.selected = id

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_left" )
    def on_edje_signal_button_action_left_pressed( self, emission, source ):
        self.page -= 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_right" )
    def on_edje_signal_button_action_right_pressed( self, emission, source ):
        self.page += 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_open" )
    def on_edje_signal_button_action_open_pressed( self, emission, source ):
        if self.selected is not None:
            if "read" in self.current[self.selected][1]:
                from_to = "From"
                timestamp = self.current[self.selected][4]["timestamp"]
            else:
                from_to = "To"
                timestamp = "Unknown"
            from_text = self.main.groups["contacts"].tryNumberToName( self.current[self.selected][2] )
            self.main.groups["text_show"].setup(
                "sms",
                "%s: %s<br>Date: %s<p>%s" % (
                    from_to,
                    from_text,
                    timestamp,
                    textblock_escape( self.current[self.selected][3] ).replace( '\n', '<br>' )
                )
            )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.main.groups["menu"].activate( ( "send", "delete", "forward", "reply" ), self.cbMenu )


#----------------------------------------------------------------------------#
class pyphone_configuration(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "configuration")
        self.selected = None
        self.profiles = []

    def onShow( self ):
        self.prepare()
        self.updateList()

    def prepare( self ):
        # Set the current profile label
        if dbus_object.prefs_obj:
            current = dbus_object.prefs_iface.GetProfile()
            self.profiles = dbus_object.prefs_iface.GetProfiles()
        else:
            current = 'Test1'
            self.profiles = ["Test1", "Test2"]
        self.part_text_set( "current_label", u"Current : %s" % current )

    def updateList( self):
        self.main.groups["configuration"].prepare()
        # We put all the profile names in the slots
        for i in range(6):
            if i < len(self.profiles):
                name = self.profiles[i]
            else:
                name = u""
            self.part_text_set( "label_main_list_%i" % i, name )
            self.part_text_set( "label_sub_list_%i" % i, u"" )
        self.selected = None
        for i in range( 6 ):
            self.signal_emit( "deactivate_target_list_%i" % i, "" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if self.selected == id:
            return
        if self.selected is not None:
            self.signal_emit( "deactivate_target_list_%i" % self.selected, "" )
        self.signal_emit( "activate_target_list_%i" % id, "" )
        self.selected = id

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_use" )
    def on_edje_signal_button_action_use_pressed( self, emission, source ):
        if self.selected is None:
            return
        if self.selected >= len(self.profiles):
            return
        profile = self.profiles[self.selected]
        self.part_text_set( "current_label", u"Current : %s" % profile )
        if dbus_object.prefs_obj:
            dbus_object.prefs_iface.SetProfile(profile)

#----------------------------------------------------------------------------#
class pyphone_contacts(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "contacts")
        self.ready = False
        self.busy = False
        self.phonebook = []
        self.current = []
        self.page = 0
        self.selected = None

    def cbNameEdit( self, name, reference ):
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                self.phonebook[i] = ( reference, name, self.phonebook[i][2] )
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_sim_iface.StoreEntry(
                        "contacts",
                        reference,
                        name,
                        self.phonebook[i][2]
                    )
                break
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.updateList()

    def cbNumberEdit( self, number, reference ):
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                self.phonebook[i] = ( reference, self.phonebook[i][1], number )
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_sim_iface.StoreEntry(
                        "contacts",
                        reference,
                        self.phonebook[i][1],
                        number
                    )
                break
        self.updateList()

    def cbNew1( self, name, none ):
        self.main.groups["number_edit"].setup(
            "contacts",
            "", # number
            name, # title = new name
            name, # reference
            self.cbNew2
        )

    def cbNew2( self, number, name ):
        ids = [ x[0] for x in self.phonebook ]
        ids.sort()
        reference = None
        for i in range(1, 250):
            if not i in ids:
                reference = i
                break
        if reference is None:
            return # no space?
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreEntry(
                "contacts",
                reference,
                name,
                number
            )
        self.phonebook.append( ( reference, name, number ) )
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.updateList()

    def cbDelete( self, result, reference ):
        if result == "abort":
            return
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.DeleteEntry(
                "contacts",
                reference
            )
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                del self.phonebook[i]
                break
        self.updateList()

    def cbMenu( self, result ):
        if result == "edit name":
            self.main.groups["text_edit"].setup(
                "contacts",
                self.current[self.selected][1], # name
                self.current[self.selected][2], # title = number
                self.current[self.selected][0], # reference
                self.cbNameEdit
            )
        elif result == "edit number":
            self.main.groups["number_edit"].setup(
                "contacts",
                self.current[self.selected][2], # number
                self.current[self.selected][1], # title = name
                self.current[self.selected][0], # reference
                self.cbNumberEdit
            )
        elif result == "new":
            self.main.groups["text_edit"].setup(
                "contacts",
                "", # name
                "name?", # title
                None, # reference
                self.cbNew1
            )
        elif result == "delete":
            self.main.groups["error"].activate(
                "delete '%s'?" % self.current[self.selected][1],
                ("abort", "delete"),
                self.current[self.selected][0], # reference
                self.cbDelete
            )

    def cbPhonebookReply( self, result ):
        logger.info( "retrieved phonebook: %s" % result )
        self.busy = False
        self.phonebook = result
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.ready = True
        self.updateList()
        self.main.groups["main"].targets["contacts"] = True
        self.main.groups["main"].update()

    def cbPhonebookError( self, e ):
        logger.error( "error while retrieving phonebook %s" % e )
        self.busy = False

    def prepare( self ):
        if not self.ready and not self.busy:
            if dbus_object.gsm_device_obj:
                logger.info( "retrieving phonebook..." )
                dbus_object.gsm_sim_iface.RetrievePhonebook(
                    "contacts",
                    reply_handler=self.cbPhonebookReply,
                    error_handler=self.cbPhonebookError
                )
                self.busy = True
            else:
                # Fake phonebook...
                self.cbPhonebookReply( [
                    (1, u'Kirk', '+023224433'),
                    (2, u'Spock', '+034433463'),
                    (3, u'McCoy', '+013244344'),
                    (4, u'Scott', '+013244344'),
                    (5, u'Uhura', '+013244344'),
                    (6, u'Sulu', '+013244344'),
                    (7, u'Chekov', '+456663443'),
                ] )

    def onReadyStatus( self, status ):
        logger.debug( "SIM is ready: %s" % status )
        if status:
            # Force update
            self.ready = False
            self.prepare()

    def onShow( self ):
        self.prepare()
        self.updateList()

    def comparePhoneNumber(self, number1, number2):
        '''
        Compares two phone numbers. They are considered equal if:
          a) One does not contain digits, and they are equal as strings
        or
          b) Both start with a "+", and all following digits are equal
        or
          c) At least one of them does not start with a "+", and the
             last 7 digits are equal
        '''
        digits1 = filter (lambda c: c.isdigit() or c == '+', number1)
        digits2 = filter (lambda c: c.isdigit() or c == '+', number2)

        if digits1 == '' or digits2 == '':
            return number1 == number2
        if digits1[0] == digits2[0] == '+':
            return digits1 == digits2
        else:
            return digits1[-7:] == digits2[-7:]

    def tryNumberToName( self, number ):
        for i in range( len( self.phonebook ) ):
            if self.comparePhoneNumber(self.phonebook[i][2], number):
                return self.phonebook[i][1]
        return number

    def updateList( self ):
        self.pages = max( ( len( self.phonebook ) - 1 ) / 6 + 1, 1 )
        if self.page >= self.pages:
            self.page = self.pages - 1
        if self.page < 0:
            self.page = 0
        self.current = self.phonebook[self.page*6:(self.page+1)*6]
        text = u"".join( [u"□"]*self.page+[u"▣"]+[u"□"]*(self.pages-self.page-1) )
        self.part_text_set( "pager", text )
        for i in range( 0, len( self.current ) ):
            self.part_text_set( "label_main_list_%i" % i, self.current[i][1] )
            self.part_text_set( "label_sub_list_%i" % i, self.current[i][2] )
        for i in range( len( self.current ), 6):
            self.part_text_set( "label_main_list_%i" % i, u"" )
            self.part_text_set( "label_sub_list_%i" % i, u"" )
        self.selected = None
        for i in range( 6 ):
            self.signal_emit( "deactivate_target_list_%i" % i, "" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if self.selected == id:
            return
        if self.selected is not None:
            self.signal_emit( "deactivate_target_list_%i" % self.selected, "" )
        self.signal_emit( "activate_target_list_%i" % id, "" )
        self.selected = id

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_left" )
    def on_edje_signal_button_action_left_pressed( self, emission, source ):
        self.page -= 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_right" )
    def on_edje_signal_button_action_right_pressed( self, emission, source ):
        self.page += 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_dial" )
    def on_edje_signal_button_action_dial_pressed( self, emission, source ):
        if self.selected is not None:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Initiate( self.current[self.selected][2], "voice" )
            else:
                # Fake onCallStatus...
                self.main.groups["call"].onCallStatus( None, "outgoing", {"peer": self.current[self.selected][2]} )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.main.groups["menu"].activate(("edit name", "edit number", "new", "delete"), self.cbMenu)

#----------------------------------------------------------------------------#
class pyphone_location( edje_group ):
#----------------------------------------------------------------------------#
    class SignalGraph( evas.ClippedSmartObject ):
        def __init__( self, *args, **kargs ):
            evas.ClippedSmartObject.__init__( self, *args, **kargs )
            self.img = self.Image()
            self.img.alpha = True
            self.img.colorspace = evas.EVAS_COLORSPACE_ARGB8888
            self.img.pos = self.pos
            self.img.show()
            self.surface = None
            self.ctx = None
            self.generic = None
            self.ubxinfo = None
            self.current = False

        def show( self ):
            super( pyphone_location.SignalGraph, self ).show()
            self.current = True

        def hide( self ):
            super( pyphone_location.SignalGraph, self ).hide()
            self.current = False

        def resize( self, w, h ):
            self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
            self.ctx = cairo.Context(self.surface)
            self.ctx.scale( w, h )
            #self.ctx.set_antialias( cairo.ANTIALIAS_NONE )
            self.img.image_size = ( w, h )
            self.update()
            self.img.resize( *self.img.image_size )
            self.img.fill_set(0, 0, *self.img.image_size )

        def update( self, generic = None, ubxinfo = None ):
            if generic is not None:
                self.generic = {}
                for sv, used, signal in generic:
                    self.generic[sv] = ( used, signal )
            if ubxinfo is not None:
                self.ubxinfo = ubxinfo[1:]
            if self.ctx and self.current:
                self.ctx.set_operator( cairo.OPERATOR_CLEAR )
                self.ctx.paint()
                self.ctx.set_operator( cairo.OPERATOR_OVER )
                pixel = self.ctx.device_to_user_distance( 1, 1 )
                self.ctx.set_line_width( max( pixel ) )
                self.ctx.set_source_rgba(1, 1, 1, 0.5)
                self.ctx.rectangle(0.0, 0.0, 1.0, 1.0)
                self.ctx.fill()
                rows = []
                if self.ubxinfo:
                    for sv in self.ubxinfo:
                        chn = sv["chn"]
                        svid = sv["SVID"]
                        used = sv["Flags"] & 0x01
                        diff = sv["Flags"] & 0x02
                        almoreph = sv["Flags"] & 0x04
                        eph = sv["Flags"] & 0x08
                        bad = sv["Flags"] & 0x10
                        qi = {
                            0: "idle",
                            1: "searching",
                            2: "searching",
                            3: "signal unusable",
                            4: "code lock",
                            5: "code&carrier lock",
                            6: "code&carrier lock",
                            7: "receiving data"
                        }[sv["QI"]]
                        cno = sv["CNO"]
                        elev = sv["Elev"]
                        azim = sv["Azim"]
                        text = "CHN %s %s SV %s: SN %i" % ( chn, qi, svid, cno )
                        if used: text += " USED"
                        if diff: text += " DIFF"
                        if almoreph and not eph: text += " ALM"
                        if eph: text += " EPH"
                        if bad: text += " BAD"
                        rows.append( ( cno, used, text ) )
                elif self.generic:
                    for sv, (used, signal) in self.generic.items():
                        text = "SV %i: SN %i" % ( sv, signal )
                        rows.append( ( signal, used, text ) )
                if rows:
                    count = len( rows )
                    maxsignal = float( max( [x[0] for x in rows] + [1.0] ) )
                    barwidth = 1.0/count
                    self.ctx.set_font_size( barwidth*0.6 )
                    index = 0
                    for signal, used, text in rows:
                        barlength = signal/maxsignal
                        if used:
                            self.ctx.set_source_rgba(0.0, 1.0, 0.0, 1.0)
                        else:
                            self.ctx.set_source_rgba(0.75, 0.75, 0.75, 1.0)
                        self.ctx.rectangle( 0.0, index*barwidth+pixel[1]*2, barlength, barwidth-pixel[1]*4 )
                        self.ctx.fill()
                        self.ctx.set_source_rgba(0, 0, 0, 1)
                        x_bearing, y_bearing, width, height = self.ctx.text_extents( text )[:4]
                        self.ctx.move_to(
                            pixel[0]*3, (index+0.5)*barwidth - height / 2 - y_bearing
                        )
                        self.ctx.show_text( text )
                        index += 1
                self.img.image_data_set( self.surface.get_data() )
                self.img.pixels_dirty = True

    class PositionGraph( evas.ClippedSmartObject ):
        def __init__( self, *args, **kargs ):
            evas.ClippedSmartObject.__init__( self, *args, **kargs )
            self.img = self.Image()
            self.img.alpha = True
            self.img.colorspace = evas.EVAS_COLORSPACE_ARGB8888
            self.img.pos = self.pos
            self.img.show()
            self.surface = None
            self.ctx = None
            self.values = []
            self.current = False

        def show( self ):
            super( pyphone_location.PositionGraph, self ).show()
            self.current = True

        def hide( self ):
            super( pyphone_location.PositionGraph, self ).hide()
            self.current = False

        def proj( self, azim, elev ):
            x = math.sin( math.radians( azim ) )*( elev/90.0 )
            y = math.cos( math.radians( azim ) )*( elev/90.0 )
            return ( x, y )

        def resize( self, w, h ):
            self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
            self.ctx = cairo.Context(self.surface)
            self.ctx.scale( w, h )
            #self.ctx.set_antialias( cairo.ANTIALIAS_NONE )
            self.img.image_size = ( w, h )
            self.update()
            self.img.resize( *self.img.image_size )
            self.img.fill_set(0, 0, *self.img.image_size )

        def update( self, values = None ):
            if values is not None:
                self.values = values
            if self.ctx and self.current:
                self.ctx.set_operator( cairo.OPERATOR_CLEAR )
                self.ctx.paint()
                self.ctx.set_operator( cairo.OPERATOR_OVER )
                self.ctx.set_line_width( max( self.ctx.device_to_user_distance( 2, 2 ) ) )
                #self.ctx.move_to(0.20, 0.10)
                #self.ctx.line_to(0.40, 0.30)
                #self.ctx.rel_line_to(-0.20, 0.0)
                #self.ctx.close_path()
                #self.ctx.stroke()
                # background
                self.ctx.set_source_rgba(1, 1, 1, 0.5)
                self.ctx.arc( 0.50, 0.50, 0.45, 0.0, math.pi*2 )
                self.ctx.fill()
                self.ctx.set_source_rgba(0, 0, 0, 1)
                self.ctx.arc( 0.50, 0.50, 0.45, 0.0, math.pi*2 )
                self.ctx.new_sub_path()
                self.ctx.arc( 0.50, 0.50, 0.30, 0.0, math.pi*2 )
                self.ctx.new_sub_path()
                self.ctx.arc( 0.50, 0.50, 0.15, 0.0, math.pi*2 )
                self.ctx.stroke()
                # locations
                for sv, used, azim, elev in self.values:
                    sv = str( sv )
                    x, y = self.proj( azim, elev )
                    if used:
                        self.ctx.set_source_rgba(0.0, 1.0, 0.0, 1.0)
                    else:
                        self.ctx.set_source_rgba(0.75, 0.75, 0.75, 1.0)
                    self.ctx.arc(
                        0.50+x*0.45,
                        0.50+y*0.45,
                        max( self.ctx.device_to_user_distance( 15, 15 ) ),
                        0.0, math.pi*2
                    )
                    self.ctx.fill()
                    self.ctx.set_source_rgba(0, 0, 0, 1)
                    self.ctx.set_font_size( max( self.ctx.device_to_user_distance( 20, 20 ) ))
                    x_bearing, y_bearing, width, height = self.ctx.text_extents(sv)[:4]
                    self.ctx.move_to(
                        0.50+x*0.45 - width / 2 - x_bearing,
                        0.50+y*0.45 - height / 2 - y_bearing
                    )
                    self.ctx.show_text( sv )
                #self.surface.write_to_png( "/tmp/zhone-location.png" )
                #self.img.file_set( "/tmp/zhone-location.png" )
                self.img.image_data_set( self.surface.get_data() )
                self.img.pixels_dirty = True

    def __init__(self, main):
        edje_group.__init__( self, main, "location" )
        self.signalgraph = self.SignalGraph( self.evas )
        self.positiongraph = self.PositionGraph( self.evas )

        self.page = "left"
        self.signal_emit( "activate_button_select_%s" % self.page, "" )

        self.accuracy = None
        self.position = None
        self.update()

        #self.signalgraph.update( values = [(1, True, 20.0), (2, False, 34.0), (5, True, 25.0), (10, False, 0.0)] )
        #self.positiongraph.update( values = [(1,  True, 20.0, 90.0), (2, False, 34.3, 45.0), (5, True, 225.9, 0.0), (10, False, 0.5, 30.0)] )

    def update( self ):
        text = []
        if self.position:
            text.append( "Lat:<tab>%s<br>Lon:<tab>%s<br>Alt:<tab>%s" % self.position )
        else:
            text.append( "Lat:<tab>N/A<br>Lon:<tab>N/A<br>Alt:<tab>N/A" )
        if self.accuracy:
            text.append( "P/H/V-DOP:<tab>%s/%s/%s" % self.accuracy )
        else:
            text.append( "P/H/V-DOP:<tab>N/A")
        if self.page == "left":
            self.part_text_set( "status", u"<br>".join( text ) )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
        elif self.page == "middle":
            self.part_text_set( "status", u"" )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
            self.part_swallow( "swallow", self.signalgraph )
            self.signalgraph.show()
        elif self.page == "right":
            self.part_text_set( "status", u"" )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
            self.part_swallow( "swallow", self.positiongraph )
            self.positiongraph.show()

    def onAccuracyChanged( self, fields, pdop, hdop, vdop ):
        self.accuracy = ( pdop, hdop, vdop )
        self.update()

    def onPositionChanged( self, fields, timestamp, lat, lon, alt ):
        self.position = ( lat, lon, alt )
        self.update()

    def onSatellitesChanged( self, satellites ):
        satellites.sort()
        signallist = [ (int(sat[0]), sat[1], float(sat[4])) for sat in satellites ]
        self.signalgraph.update( generic = signallist )
        positionlist = [ (int(sat[0]), sat[1], int(sat[3]), int(sat[2])) for sat in satellites ]
        self.positiongraph.update( positionlist )

    def onUBXDebugPacket( self, clid, length, data ):
        if clid == "NAV-SVINFO":
            self.signalgraph.update( ubxinfo = data )

    def onShow( self ):
        self.main.agents["usage"].request( "GPS" )
        self.update()

    def onHide( self ):
        self.main.agents["usage"].release( "GPS" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_select_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        self.page = source.split( "_" )[-1]
        self.signal_emit( "deactivate_button_select_left", "" )
        self.signal_emit( "deactivate_button_select_middle", "" )
        self.signal_emit( "deactivate_button_select_right", "" )
        self.signal_emit( "activate_button_select_%s" % self.page, "" )
        self.update()

#----------------------------------------------------------------------------#
class pyphone_message(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "message")
        self.text = []
        self.button_labels2 = [
            [
                [u".,?!", u"abc", "def", ""],
                [u"ghi", u"jkl", "mno", ""],
                [u"pqrs", u"tuv", "wxyz", ""],
                [u"", u"", u"⇦⇧⇨", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.button_labels = [
            [
                ["1", "2", "3", u"↤"],
                ["4", "5", "6", u"↲"],
                ["7", "8", "9", "Abc"],
                ["+", "0", u"⇩", "+"],
            ],
            [
                ["1", "?", "", ""],
                [".", ",", "", ""],
                ["!", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "2", "c", ""],
                ["", "a", "b", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "3", "f"],
                ["", "", "d", "e"],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", u"↤"],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["4", "i", "", ""],
                ["g", "h", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "5", "l", ""],
                ["", "j", "k", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "6", "o"],
                ["", "", "m", "n"],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "s", "", ""],
                ["7", "r", "", ""],
                ["p", "q", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "8", "v", ""],
                ["", "t", "u", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", "z"],
                ["", "", "9", "y"],
                ["", "", "w", "x"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", " ", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", u"⇧", ""],
                ["", u"⇦", u"⇩", u"⇨"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.set_button_text(0)
        self.active = 0

    @edje.decorators.signal_callback("kb_button_mouse_up", "*")
    def on_edje_signal_dialer_button_mouse_up(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        key = self.button_labels[self.active][y][x]
        self.text.append(key)
        # The trailing whitespace is a workaround for the one char invisible
        # bug due to some problems with scaling of text parts.
        self.part_text_set("label", "".join(self.text)+" ")
        self.set_button_text(0)
        logger.debug( "mouse up: %s" % time.time()-now )

    @edje.decorators.signal_callback("kb_button_mouse_down", "*")
    def on_edje_signal_dialer_button_mouse_down(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        num = 4*y+x+1
        if self.active == 0:
            self.set_button_text(num)
        logger.debug( "mouse down: %s" % time.time()-now )

    @edje.decorators.signal_callback("kb_button_mouse_in", "*")
    def on_edje_signal_dialer_button_mouse_in(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        self.part_text_set("label_preview", self.button_labels[self.active][y][x])
        logger.debug( "mouse in: %s" % time.time()-now )

    def set_button_text(self, num):
        for i in xrange(4):
            for j in xrange(4):
                text = self.button_labels[num][j][i]
                self.part_text_set("label_%d_%d" % (i,j) , text)
        self.active = num

        if num != 0:
            num = 1

        for i in xrange(4):
            for j in xrange(4):
                text = self.button_labels2[num][j][i]
                self.part_text_set("label2_%d_%d" % (i,j) , text)

#----------------------------------------------------------------------------#
class pyphone_list_choose(edje_group):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "list_choose" )
        self.text = ""
        self.list_data = None
        self.cb_data = None
        self.cb = None

    def updateList( self):
        self.pages = max( ( len( self.list_data ) - 1 ) / 6 + 1, 1 )
        if self.page >= self.pages:
            self.page = self.pages - 1
        if self.page < 0:
            self.page = 0
        self.current = self.list_data[self.page*6:(self.page+1)*6]
        self.part_text_set( "pager", u"".join( [u"□"]*self.page+[u"▣"]+[u"□"]*(self.pages-self.page-1) ) )
        for i in range( 0, len( self.current ) ):
            self.part_text_set( "label_main_list_%i" % i, self.current[i][0] )
            self.part_text_set( "label_sub_list_%i" % i, self.current[i][1] )
        for i in range( len( self.current ), 6):
            self.part_text_set( "label_main_list_%i" % i, u"" )
            self.part_text_set( "label_sub_list_%i" % i, u"" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        self.main.transition_to(self.parent_name)
        self.cb( self.current[id], self.cb_data )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_left" )
    def on_edje_signal_button_action_left_pressed( self, emission, source ):
        self.page -= 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_right" )
    def on_edje_signal_button_action_right_pressed( self, emission, source ):
        self.page += 1
        self.updateList()

    def setup( self, parent_name, list_data, cb_data, cb ):
        self.parent_name = parent_name
        self.list_data = list_data
        self.cb_data = cb_data
        self.cb = cb

        self.current = []
        self.page = 0
        self.main.transition_to("list_choose")

        self.updateList()

#----------------------------------------------------------------------------#
class pyphone_number_edit( edje_group ):
#----------------------------------------------------------------------------#
    TIMEOUT = 2.0
    def __init__( self, main ):
        edje_group.__init__( self, main, "number_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None
        self.last = 0.0

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key in ( "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "#" ):
            self.text += key
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "star":
            if self.text and ( time.time()-self.last < self.TIMEOUT ):
                if self.text[-1] == "*":
                    self.text = self.text[:-1]+"+"
                elif self.text[-1] == "+":
                    self.text = self.text[:-1]+"*"
                else:
                    self.text += "*"
            else:
                self.text += "*"
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "hash":
            self.text += "#"
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
        self.last = time.time()

    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", u" %s " % self.title )
        self.part_text_set( "label", u" %s " % self.text )
        self.main.transition_to("number_edit")

#----------------------------------------------------------------------------#
class pyphone_pin_edit( edje_group ):
#----------------------------------------------------------------------------#
    DELAY = 1.0
    def __init__( self, main ):
        edje_group.__init__( self, main, "number_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None
        self.timer = None
        self.last = 0.0
        self.part_text_set( "label_main_star", u"" )
        self.part_text_set( "label_sub_star", u"" )
        self.part_text_set( "label_main_hash", u"" )
        self.part_text_set( "label_sub_hash", u"" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key in ( "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ):
            self.text += key
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            output = u"●"*( len( self.text ) - 1) + self.text[-1]
            self.part_text_set( "label", u" %s " % output )
            if self.timer:
                self.timer.delete()
            self.timer = ecore.timer_add( self.DELAY, self.timerCb )
        elif key in "delete":
            self.text = self.text[:-1]
            output = u"●"*len( self.text )
            self.part_text_set( "label", u" %s " % output )
        elif key in "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
        self.last = time.time()

    def timerCb( self ):
        output = u"●"*len( self.text )
        self.part_text_set( "label", u" %s " % output )
        self.timer = None
        return False

    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", u" %s " % self.title )
        self.part_text_set( "label", u" %s " % self.text )
        self.main.transition_to("pin_edit")

#----------------------------------------------------------------------------#
class pyphone_text_show( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "text_show" )

    def setup( self, parent_name, text ):
        self.parent_name = parent_name
        self.part_text_set( "text", text )
        self.main.transition_to("text_show")

#----------------------------------------------------------------------------#
class pyphone_text_edit( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "text_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None
        self.shift_down = False

    def onShow( self ):
        self.focus = True
        if illume:
            illume.kbd_show()

    def onHide( self ):
        self.focus = False
        if illume:
            illume.kbd_hide()

    @evas.decorators.key_down_callback
    def on_key_down( self, event ):
        key = event.string
        if key == "\x08":
            self.text = self.text[:-1]
        elif key is not None:
            self.text += key
        self.part_text_set( "label", self.text )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key == "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
        elif key == "cancel":
            self.main.transition_to(self.parent_name)

    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", u" %s " % self.title )
        self.part_text_set( "label", self.text )
        self.main.transition_to("text_edit")

#----------------------------------------------------------------------------#
class pyphone_menu( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "menu" )
        self.buttons = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_*" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        if source == "target_cancel":
            self.deactivate()
            self.cb( "cancel" )
        else:
            id = int( source.split( "_", 1 )[1] )
            self.deactivate()
            self.cb( self.part_text_get( "target_label_%i" % id ) )

    def activate( self, buttons, cb ):
        self.buttons = buttons
        self.cb = cb
        count = len( buttons )
        assert count == 4
        self.part_text_set( "target_label_0", buttons[0] )
        self.part_text_set( "target_label_1", buttons[1] )
        self.part_text_set( "target_label_2", buttons[2] )
        self.part_text_set( "target_label_3", buttons[3] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )


#----------------------------------------------------------------------------#
class pyphone_main_menu( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "main_menu" )
        self.signal_emit( "invisible", "" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if( id == 5 ):
          os.system("halt")
        if( id == 0 ):
          fp = os.popen("sleep 5 && \
                         n=/tmp/scap$$.png && \
                         fbgrab $n && \
                         curl \
                          -F file=@$n \
                          -F key=secret \
                          -F model=`uname -n` \
                          -F submit=Upload \
                          -F text=no\ comment \
                          http://scap.linuxtogo.org/tickle.php && \
                         rm $n &")

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_cancel" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.deactivate()

    def activate( self, group ):
        self.group = group
        self.signal_emit( "visible", "" )
        for i in range( 1, 5 ):
          self.part_text_set( "label_main_list_%i" % i, u"" )
          self.part_text_set( "label_sub_list_%i" % i, u"" )

        self.part_text_set( "label_main_list_0", u"Take screenshot" )
        self.part_text_set( "label_sub_list_0", u"and upload to http://scap.linuxtogo.org" )
        self.part_text_set( "label_main_list_5", u"Exit" )
        self.part_text_set( "label_sub_list_5", u"Stop and exit Zhone" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )
        self.main.transition_to(self.group)

#----------------------------------------------------------------------------#
class pyphone_lock( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "lock" )
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "target_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        if id == self.step+1: # correct button
            self.signal_emit( "activate_%i" % id, "" )
            self.step += 1
        else:
            for id in range( 1, 5 ):
                self.signal_emit( "deactivate_%i" % id, "" )
            self.step = 0
        if self.step == 4:
            self.signal_emit( "invisible", "" )

    def activate( self ):
        self.step = 0
        for id in range( 1, 5 ):
            self.signal_emit( "deactivate_%i" % id, "" )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class pyphone_error( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "error" )
        self.buttons = None
        self.cb_data = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        self.deactivate()
        self.cb( self.part_text_get( "label_%i" % id ), self.cb_data )

    def activate( self, description, buttons, cb_data, cb ):
        self.buttons = buttons
        self.cb_data = cb_data
        self.cb = cb
        count = len( buttons )
        assert 1 <= count <= 3
        self.part_text_set( "description", description )
        if count == 1:
            self.signal_emit( "hide_0", "" )
            self.part_text_set( "label_0", u"" )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[0] )
            self.signal_emit( "hide_2", "" )
            self.part_text_set( "label_2", u"" )
        elif count == 2:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "hide_1", "" )
            self.part_text_set( "label_1", u"" )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[1] )
        elif count == 3:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[1] )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[2] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class Agent( object ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        super( Agent, self ).__init__()
        self.main = main
        self.state = "Waiting for DBus"
        self.onState = []

    def registerStateCallback( self, callback ):
        self.onState.append( callback )

    def setState( self, state ):
        logger.debug( state )
        self.state = state
        for cb in self.onState:
            cb( self.name, state )

#----------------------------------------------------------------------------#
class UsageAgent( Agent ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        super( UsageAgent, self ).__init__( main )
        self.name = "Usage"
        self.busy = None
        self.want = set( ["GSM"] )
        self.avail = set()
        self.have = set()
        self.error = set()

    def _update( self ):
        self.main.groups["main"].targets["location"] = "GPS" in (self.avail - self.error)
        self.main.groups["main"].update()
        if self.busy is None:
            pendingRequests = (self.avail & self.want) - self.have - self.error
            pendingReleases = self.have - self.want
            if pendingRequests:
                self.busy = pendingRequests.pop()
                self.setState( "Requesting resource %s" % self.busy )
                dbus_object.usage_iface.RequestResource(
                    self.busy,
                    reply_handler=self.cbRequestReply,
                    error_handler=self.cbRequestError,
                )
            elif pendingReleases:
                self.busy = pendingReleases.pop()
                self.setState( "Releasing resource %s" % self.busy )
                dbus_object.usage_iface.ReleaseResource(
                    self.busy,
                    reply_handler=self.cbReleaseReply,
                    error_handler=self.cbReleaseError,
                )

    def cbRequestReply( self ):
        self.have.add( self.busy )
        self.setState( "Requested resource %s" % self.busy )
        if self.busy == "GSM":
            self.main.agents["gsm"].cbResourceReady()
        elif self.busy == "GPS":
            self.main.agents["gps"].cbResourceReady()
        self.busy = None
        self._update()

    def cbRequestError( self, e ):
        log_dbus_error( e, "error while requesting resource %s" % self.busy )
        self.setState( "Requested resource %s with error" % self.busy )
        self.error.add( self.busy )
        self.busy = None
        self._update()

    def cbReleaseReply( self ):
        self.have.discard( self.busy )
        self.setState( "Released resource %s" % self.busy )
        self.busy = None
        self._update()

    def cbReleaseError( self, e ):
        log_dbus_error( e, "error while releasing resource %s" % self.busy )
        self.setState( "Released resource %s with error" % self.busy )
        self.have.discard( self.busy )
        self.error.add( self.busy )
        self.busy = None
        self._update()

    def cbDBusReady( self ):
        self.setState( "Requesting resource list" )
        self.avail = set( dbus_object.usage_iface.ListResources() )
        self._update()

    def cbResourceAvailable( self, resourcename, state ):
        if state:
            self.setState( "Resource added %s" % resourcename )
            self.avail.add( resourcename )
        else:
            self.setState( "Resource removed %s" % resourcename )
            self.avail.discard( resourcename )
        self._update()

    def request( self, resourcename ):
        self.want.add( resourcename )
        self._update()

    def release( self, resourcename ):
        self.want.remove( resourcename )
        self._update()

#----------------------------------------------------------------------------#
class GSMAgent( Agent ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        super( GSMAgent, self ).__init__( main )
        self.name = "GSM"

    def cbResourceReady( self ):
        """
        This is called to start the authentication process
        """
        self.setState( "Turning on Antenna" )
        dbus_object.gsm_device_iface.SetAntennaPower(
            True,
            reply_handler=self.cbAntennaPowerReply,
            error_handler=self.cbAntennaPowerError,
        )

    def cbAntennaPowerReply( self ):
        logger.info( "Antenna power OK. Registering to network now." )
        self.setState( "Registering to network" )
        dbus_object.gsm_network_iface.Register(
            reply_handler=self.cbRegisterReply,
            error_handler=self.cbRegisterError
        )

    def cbAntennaPowerError( self, e ):
        logger.info( "SIM seems to be protected. Checking auth status now." )
        self.setState( "Reading authentication status" )
        dbus_object.gsm_sim_iface.GetAuthStatus(
            reply_handler=self.cbAuthStatusReply,
            error_handler=self.cbAuthStatusError,
        )

    def cbAuthStatusReply( self, authstatus ):
        if authstatus == "READY":
            self.setState( "Telephony Ready" )
            # restart auth, should lead to registering this time...
            self.cbResourceReady()
        elif authstatus == "SIM PIN":
            self.setState( "Waiting for PIN" )
            self.main.groups["pin_edit"].setup(
                "main",
                "", # number
                "Enter PIN", # title
                None, # reference
                self.cbPINDone
            )
        elif authstatus == "SIM PUK":
            self.setState( "Waiting for PUK" )
            self.main.groups["pin_edit"].setup(
                "main",
                "", # number
                "Enter PUK", # title
                None, # reference
                self.cbPUKDone
            )
        else:
            logger.exception( "Unknown authentication status %s" % authstatus )

    def cbAuthStatusError( self, e ):
        self.setState( "Failed to read authentication status" )
        logger.exception( e )

    def cbPINDone( self, pin, *args ):
        self.setState( "Sending PIN" )
        dbus_object.gsm_sim_iface.SendAuthCode(
            pin,
            reply_handler=self.cbAuthCodeReply,
            error_handler=self.cbAuthCodeError
        )

    def cbAuthCodeReply( self ):
        self.cbAuthStatusReply( "READY" )

    def cbAuthCodeError( self, e ):
        self.setState( "Error while sending PIN" )
        logger.exception( e )
        # retry
        self.cbDBusReady()

    def cbPUKDone( self, puk, *args ):
        self.main.groups["pin_edit"].setup(
            "main",
            "", # number
            "Enter new PIN", # title
            puk, # reference
            self.cbNewPINDone
        )

    def cbNewPINDone( self, pin, puk ):
        self.setState( "Sending PUK and new PIN" )
        dbus_object.gsm_sim_iface.Unlock(
            pin, puk,
            reply_handler=self.cbUnlockReply,
            error_handler=self.cbUnlockError
        )

    def cbUnlockReply( self ):
        self.cbAuthStatusReply( "READY" )

    def cbUnlockError( self, e ):
        self.setState( "Error while sending PIN" )
        logger.exception( e )
        # retry
        self.cbResourceReady()

    def cbRegisterReply( self ):
        pass

    def cbRegisterError( self, e ):
        logger.exception( e )
        if dbus_object.gsm_sim_iface.GetSimReady():
            self.main.groups["contacts"].prepare()
            self.main.groups["sms"].prepare()

#----------------------------------------------------------------------------#
class GPSAgent( Agent ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        super( GPSAgent, self ).__init__( main )
        self.name = "GPS"
        self.busy = None
        self.want = set( ["NAV-SVINFO"] )
        self.have = set()
        self.error = set()

    def _update( self ):
        if self.busy is None:
            pending = self.want - self.have - self.error
            if pending:
                self.busy = pending.pop()
                self.setState( "Requesting packet %s" % self.busy )
                dbus_object.gps_ubx_iface.SetDebugFilter(
                    self.busy,
                    True,
                    reply_handler=self.cbSetDebugReply,
                    error_handler=self.cbSetDebugError,
                )

    def cbResourceReady( self ):
        self.setState( "Requesting debug packets." )
        self.have = set()
        self._update()

    def cbSetDebugReply( self ):
        self.have.add( self.busy )
        self.setState( "Requested debug packet %s" % self.busy )
        self.busy = None
        self._update()

    def cbSetDebugError( self, e ):
        log_dbus_error( e, "error while requesting debug packet %s" % self.busy )
        self.setState( "Requested debug packet %s with error" % self.busy )
        self.error.add( self.busy )
        self.busy = None
        self._update()

#----------------------------------------------------------------------------#
class GUI(object):
#----------------------------------------------------------------------------#
    def __init__( self, options, args ):

        logger.debug( "GUI init" )

        edje.frametime_set(1.0 / options.fps)

        self.evas_canvas = EvasCanvas(
            fullscreen = options.fullscreen,
            engine = options.engine,
            size = options.geometry
        )

        self.agents = {}

        self.agents["usage"] = agent = UsageAgent( self )
        agent.registerStateCallback( self.onAgentStateChanged )
        dbus_object.onResourceAvailable.append( self.agents["usage"].cbResourceAvailable )

        self.agents["gsm"] = agent = GSMAgent( self )
        agent.registerStateCallback( self.onAgentStateChanged )

        self.agents["gps"] = agent = GPSAgent( self )
        agent.registerStateCallback( self.onAgentStateChanged )

        self.groups = {}

        self.groups["swallow"] = edje_group(self, "swallow")
        self.evas_canvas.evas_obj.data["swallow"] = self.groups["swallow"]

        for page in (
                "main",
                "phone", "call", "dtmf",
                "sms",
                "contacts",
                "location",
                "configuration",
                "list_choose", "number_edit", "pin_edit", "text_edit", "text_show", "message"
            ):
            ctor = globals().get( "pyphone_%s" % page, None )
            if ctor:
                self.groups[page] = ctor( self )
                self.evas_canvas.evas_obj.data[page] = self.groups[page]

        for overlay in ("main_menu", "menu", "lock", "error"):
            ctor = globals().get( "pyphone_%s" % overlay, None )
            if ctor:
                self.groups[overlay] = ctor( self )
                self.evas_canvas.evas_obj.data[overlay] = self.groups[overlay]
                self.groups["swallow"].part_swallow( overlay, self.groups[overlay] )

        self.groups["swallow"].show()

        self.current_group = self.groups[options.start]
        self.previous_group = None
        self.groups["swallow"].part_swallow("swallow", self.current_group)
        ecore.timer_add(60.0, self.display_time)
        self.display_time()

        ecore.idle_enterer_add( self.dbus_objectInit )

        dbus_object.onAccuracyChanged.append( self.groups["location"].onAccuracyChanged )
        dbus_object.onPositionChanged.append( self.groups["location"].onPositionChanged )
        dbus_object.onSatellitesChanged.append( self.groups["location"].onSatellitesChanged )
        dbus_object.onUBXDebugPacket.append( self.groups["location"].onUBXDebugPacket )
        dbus_object.onCallStatus.append( self.groups["call"].onCallStatus )
        dbus_object.onReadyStatus.append( self.groups["contacts"].onReadyStatus )
        dbus_object.onReadyStatus.append( self.groups["sms"].onReadyStatus )
        dbus_object.onIncomingMessage.append( self.groups["sms"].onIncomingMessage )
        dbus_object.onIdleStateChanged.append( self.lock_on_idle )
        dbus_object.onNetworkStatus.append( self.groups["phone"].onNetworkStatus )

        logger.debug( "GUI init done" )

    def run( self ):
        logger.debug( "entering mainloop" )
        ecore.main_loop_begin()

    def shutdown( self ):
        ecore.main_loop_quit()

    def dbus_objectInit( self ):
        logger.debug( "dbus_objectInit..." )
        if not dbus_object.initialize():
            self.display_state( "connecting w/ dbus..." )
            # try again later
            ecore.timer_add( 10.0, self.dbus_objectInit )
            return False
        else:
            logger.debug( "dbus_objectInitOK!" )
            self.agents["usage"].cbDBusReady()
        return False

    def lock_on_idle( self, state ):
        if state == "lock":
            self.groups["lock"].activate()

    def display_time(self):
        self.groups["main"].part_text_set("label", time.strftime("%H:%M", time.localtime()))
        self.groups["main"].part_text_set("label_year", time.strftime("%Y-%m-%d", time.localtime()))
        return True

    def display_state(self, state):
        self.groups["main"].part_text_set("label_year", state )

    # TODO better state management for transitions
    def transition_to(self, target):
        if self.current_group == self.groups[target]:
            return
        logger.debug( "transition to %s" % target )

        self.previous_group = self.current_group
        self.previous_group.onHide()
        self.previous_group.hide()

        self.current_group = self.groups[target]
        self.current_group.onShow()
        self.current_group.signal_emit("visible", "")
        self.groups["swallow"].part_swallow("swallow", self.current_group)
        self.previous_group.signal_emit("invisible", "")

    def onAgentStateChanged( self, agentname, state ):
        self.display_state( "%s: %s" % ( agentname, state ) )

#----------------------------------------------------------------------------#
class EvasCanvas(object):
#----------------------------------------------------------------------------#
    def __init__(self, fullscreen, engine, size):
        if engine == "x11":
            f = ecore.evas.SoftwareX11
        elif engine == "x11-16":
            if ecore.evas.engine_type_supported_get("software_x11_16"):
                f = ecore.evas.SoftwareX11_16
            else:
                logger.warning( "x11-16 is not supported, fallback to x11" )
                f = ecore.evas.SoftwareX11

        self.evas_obj = f(w=size[0], h=size[1])
        self.evas_obj.callback_delete_request = self.on_delete_request
        self.evas_obj.callback_resize = self.on_resize

        self.evas_obj.title = TITLE
        self.evas_obj.name_class = (WM_NAME, WM_CLASS)
        self.evas_obj.fullscreen = fullscreen
        self.evas_obj.size = size
        self.evas_obj.evas.image_cache_set( 6*1024*1024 )
        self.evas_obj.evas.font_cache_set( 2*1024*1024 )
        self.evas_obj.show()

    def on_resize(self, evas_obj):
        x, y, w, h = evas_obj.evas.viewport
        size = (w, h)
        evas_obj.data["swallow"].size = size

    def on_delete_request(self, evas_obj):
        ecore.main_loop_quit()

#----------------------------------------------------------------------------#
class MyOptionParser(OptionParser):
#----------------------------------------------------------------------------#
    def __init__(self):
        OptionParser.__init__(self)
        self.set_defaults(fullscreen = False)
        self.add_option("-e",
                      "--engine",
                      type="choice",
                      choices=("x11", "x11-16"),
                      default="x11-16",
                      help=("which display engine to use (x11, x11-16), "
                            "default=%default"))
        self.add_option("--fullscreen",
                      action="store_true",
                      dest="fullscreen",
                      help="launch in fullscreen")
        self.add_option("--no-fullscreen",
                      action="store_false",
                      dest="fullscreen",
                      help="launch in a window")
        self.add_option("-g",
                      "--geometry",
                      type="string",
                      metavar="WxH",
                      action="callback",
                      callback=self.parse_geometry,
                      default=(WIDTH, HEIGHT),
                      help="use given window geometry")
        self.add_option("-f",
                      "--fps",
                      type="int",
                      default=20,
                      help="frames per second to use, default=%default")
        self.add_option("-s",
                      "--start",
                      type="string",
                      default="main",
                      help="start with the given page")

    def parse_geometry(option, opt, value, parser):
        try:
            w, h = value.split("x")
            w = int(w)
            h = int(h)
        except Exception, e:
            raise optparse.OptionValueError("Invalid format for %s" % option)
        parser.values.geometry = (w, h)

#----------------------------------------------------------------------------#
class DBusObject( object ):
#----------------------------------------------------------------------------#
    def __init__( self ):
        self.objects = {}
        self.onResourceChanged = []
        self.onResourceAvailable = []
        self.onAccuracyChanged = []
        self.onPositionChanged = []
        self.onSatellitesChanged = []
        self.onUBXDebugPacket = []
        self.onCallStatus = []
        self.onReadyStatus = []
        self.onNetworkStatus = []
        self.onIncomingMessage = []
        self.onIdleStateChanged = []
        self.onInputEvent = []

        self.framework_obj = None

        self.usage_obj = None
        self.usage_iface = None

        self.gps_obj = None
        self.gps_accuracy_iface = None
        self.gps_position_iface = None
        self.gps_satellite_iface = None
        self.gps_ubx_iface = None

        self.gsm_device_obj = None
        self.gsm_device_iface = None
        self.device_iface = None
        self.idlenotifier_obj = None
        self.idlenotifier_iface = None
        self.inputnotifier_obj = None
        self.inputnotifier_iface = None
        self.prefs_obj = None
        self.prefs_iface = None

        self.fullinit = False

    def tryGetProxy( self, busname, objname ):
        object = None
        try:
            object = self.objects[ "%s:%s" % ( busname, objname ) ]
        except KeyError:
            try:
                object = self.bus.get_object( busname, objname )
            except DBusException, e:
                logger.warning( "could not create proxy for %s:%s" % ( busname, objname ) )
            else:
                self.objects[ "%s:%s" % ( busname, objname ) ] = object
        return object

    def initialize( self ):
        if self.fullinit:
            return True
        try:
            self.bus = SystemBus( mainloop=e_dbus.DBusEcoreMainLoop() )
        except DBusException, e:
            logger.error( "could not connect to dbus_object system bus: %s" % e )
            return False

        # Framework
        fw_obj = self.tryGetProxy( 'org.freesmartphone.frameworkd', '/org/freesmartphone/Framework' )
        if fw_obj is None:
            logger.error( "could not connect to org.freesmartphone.frameworkd -- is the framework daemon started?" )
            return False
        else:
            self.fw = Interface( fw_obj, "org.freesmartphone.Framework" )
        failcount = 0

        # Usage
        self.usage_obj = self.tryGetProxy( 'org.freesmartphone.ousaged', '/org/freesmartphone/Usage' )
        if ( self.usage_obj is not None ) and ( self.usage_iface is None ):
            self.usage_iface = Interface(self.usage_obj, 'org.freesmartphone.Usage')
            self.usage_iface.connect_to_signal( "ResourceChanged", self.cbResourceChanged )
            self.usage_iface.connect_to_signal( "ResourceAvailable", self.cbResourceAvailable )
        if self.usage_obj is None:
            failcount += 1
        else:
            logger.debug( "usage ok: %s" % self.usage_iface )

        # GPS
        self.gps_obj = self.tryGetProxy( 'org.freesmartphone.ogpsd', '/org/freedesktop/Gypsy' )
        if self.gps_obj and not self.gps_accuracy_iface:
            self.gps_accuracy_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Accuracy')
            self.gps_accuracy_iface.connect_to_signal( "AccuracyChanged", self.cbAccuracyChanged )
        if self.gps_obj and not self.gps_position_iface:
            self.gps_position_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Position')
            self.gps_position_iface.connect_to_signal( "PositionChanged", self.cbPositionChanged )
        if self.gps_obj and not self.gps_satellite_iface:
            self.gps_satellite_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Satellite')
            self.gps_satellite_iface.connect_to_signal( "SatellitesChanged", self.cbSatellitesChanged )
        if self.gps_obj and not self.gps_ubx_iface:
            self.gps_ubx_iface = Interface(self.gps_obj, 'org.freesmartphone.GPS.UBX')
            self.gps_ubx_iface.connect_to_signal( "DebugPacket", self.cbUBXDebugPacket )
        if not self.gps_obj or not self.gps_accuracy_iface or not self.gps_position_iface \
            or not self.gps_satellite_iface:
            failcount += 1
        else:
            logger.debug( "gps ok: %s, %s, %s" % ( self.gps_accuracy_iface, self.gps_position_iface, self.gps_satellite_iface ) )

        # Phone
        self.gsm_device_obj = self.tryGetProxy( 'org.freesmartphone.ogsmd', '/org/freesmartphone/GSM/Device' )

        if ( self.gsm_device_obj is not None ) and ( self.gsm_device_iface is None ):
            self.gsm_device_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Device')
            self.gsm_sim_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.SIM')
            self.gsm_network_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Network')
            self.gsm_call_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Call')
            self.gsm_test_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Test')
            self.gsm_sim_iface.connect_to_signal( "IncomingStoredMessage", self.cbIncomingMessage )
            self.gsm_sim_iface.connect_to_signal( "ReadyStatus", self.cbReadyStatus )
            self.gsm_call_iface.connect_to_signal( "CallStatus", self.cbCallStatus )
            self.gsm_network_iface.connect_to_signal( "Status", self.cbNetworkStatus )
        if self.gsm_device_obj is None:
            failcount += 1
        else:
            logger.debug( "gsm ok: %s" % self.gsm_network_iface )

        self.device_obj = self.tryGetProxy( 'org.freesmartphone.odeviced', '/org/freesmartphone/Device' )
        if ( self.device_obj is not None ) and ( self.device_iface is None ):
            self.device_iface = Interface( self.device_obj, 'org.freesmartphone.Device' )

            self.idlenotifier_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.IdleNotifier" )[0] )

            self.idlenotifier_iface = Interface( self.idlenotifier_obj, "org.freesmartphone.Device.IdleNotifier" )
            self.idlenotifier_iface.connect_to_signal( "State", self.cbIdleStateChanged )

            self.inputnotifier_obj = self.bus.get_object( "org.freesmartphone.odeviced", "/org/freesmartphone/Device/Input" )
            self.inputnotifier_iface = Interface( self.inputnotifier_obj, "org.freesmartphone.Device.Input" )
            self.inputnotifier_iface.connect_to_signal( "Event", self.cbEvent )
        if self.device_obj is None:
            failcount += 1
        else:
            logger.debug( "device ok: %s" % self.device_iface )

        # Prefs
        self.prefs_obj = self.tryGetProxy( 'org.freesmartphone.opreferencesd', '/org/freesmartphone/Preferences' )
        self.prefs_iface = Interface( self.prefs_obj, 'org.freesmartphone.Preferences' )
        logger.debug( "preferences ok: %s" % self.prefs_iface )

        logger.debug( "failcount = %d" % failcount )
        if failcount == 0:
            self.fullinit = True
        return self.fullinit

    def cbResourceChanged( self, resourcename, state, attributes ):
        for cb in self.onResourceChanged:
            cb( resourcename=resourcename, state=state, attributes=attributes )

    def cbResourceAvailable( self, resourcename, state ):
        for cb in self.onResourceAvailable:
            cb( resourcename=resourcename, state=state )

    def cbAccuracyChanged( self, fields, pdop, hdop, vdop ):
        for cb in self.onAccuracyChanged:
            cb( fields=fields, pdop=pdop, hdop=hdop, vdop=vdop )

    def cbPositionChanged( self, fields, timestamp, lat, lon, alt ):
        for cb in self.onPositionChanged:
            cb( fields=fields, timestamp=timestamp, lat=lat, lon=lon, alt=alt )

    def cbSatellitesChanged( self, satellites ):
        for cb in self.onSatellitesChanged:
            cb( satellites )

    def cbUBXDebugPacket( self, clid, length, data ):
        try:
            for cb in self.onUBXDebugPacket:
                cb( clid, length, data )
        except e:
            logger.exception("error in callback")

    def cbCallStatus( self, id, status, properties ):
        logger.info( "CALL STATUS = %d, %s, %s" % ( id, status, properties ) )
        for cb in self.onCallStatus:
            cb( id=id, status=status, properties=properties )
        if not self.idlenotifier_iface is None:
            self.idlenotifier_iface.SetState(
                "busy",
                reply_handler=lambda: None,
                error_handler=handle_dbus_error( "could not set idle state to busy" )
            )

    def cbReadyStatus( self, status ):
        for cb in self.onReadyStatus:
            cb( status=status )

    def cbNetworkStatus( self, status ):
        for cb in self.onNetworkStatus:
            cb( status=status )

    def cbIncomingMessage( self, index ):
        for cb in self.onIncomingMessage:
            cb( index=index )

    def cbIdleStateChanged( self, state ):
        logger.info( "IDLE STATE = %s" % state )
        for cb in self.onIdleStateChanged:
            cb( state=state )

    def cbEvent( self, name, action, seconds ):
        logger.info( "INPUT EVENT = %s, %s, %d" % ( name, action, seconds ) )
        for cb in self.onInputEvent:
            cb( name, action, seconds )

#=========================================================================#
if __name__ == "__main__":
#=========================================================================#

    options, args = MyOptionParser().parse_args()
    dbus_object = DBusObject()
    gui = GUI( options, args )
    try:
        gui.run()
    except KeyboardInterrupt:
        gui.shutdown()
        del gui
