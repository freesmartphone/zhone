#!/usr/bin/env python
#coding=utf8
"""
Zen Phone - A Phone UI

(C) 2007 Johannes 'Josch' Schauer
(C) 2008 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
(C) 2008 Jan 'Shoragan' Luebbe
(C) 2008 Daniel 'Alphaone' Willmann
(C) 2008 Openmoko, Inc.
GPLv2 or later
"""

#----------------------------------------------------------------------------#
WIDTH = 480
HEIGHT = 640

TITLE = "zhone"
WM_NAME = "zhone"
WM_CLASS = "zhone"

#----------------------------------------------------------------------------#
import os
import sys
import e_dbus
import evas
import evas.decorators
import edje
import edje.decorators
import ecore
import ecore.evas
from dbus import SystemBus, Interface
from dbus.exceptions import DBusException
from optparse import OptionParser
import time

illume = None
try:
    import illume
except:
    print "could not load illume interface"

#----------------------------------------------------------------------------#

edjepaths = "../data/themes/zhone.edj ../share/zhone.edj /usr/local/share/zhone/zhone.edj /usr/share/zhone/zhone.edj".split()

for i in edjepaths:
    if os.path.exists( i ):
       global edjepath
       edjepath = i
       break
else:
    raise Exception( "zhone.edj not found. looked in %s" % edjepaths )

#----------------------------------------------------------------------------#
class edje_group(edje.Edje):
#----------------------------------------------------------------------------#
    def __init__(self, main, group, parent_name="main"):
        self.main = main
        self.parent_name = parent_name
        global edjepath
        f = edjepath
        try:
            edje.Edje.__init__(self, self.main.evas_canvas.evas_obj.evas, file=f, group=group)
        except edje.EdjeLoadError, e:
            raise SystemExit("error loading %s: %s" % (f, e))
        self.size = self.main.evas_canvas.evas_obj.evas.size

    def onShow( self ):
        pass

    def onHide( self ):
        pass

    @edje.decorators.signal_callback("mouse,clicked,1", "button_bottom_right")
    def on_edje_signal_button_bottom_right_pressed(self, emission, source):
        self.main.transition_to(self.parent_name)

    @edje.decorators.signal_callback("finished_transition", "*")
    def on_edje_signal_finished_transition(self, emission, source):
        self.main.transition_finished()

#----------------------------------------------------------------------------#
class pyphone_main(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "main")

    @edje.decorators.signal_callback("mouse,clicked,1", "target_*")
    def on_edje_signal_button_pressed(self, emission, source):
        target = source.split('_', 1)[1]
        if target == "phone" and not self.main.groups["call"].status in ["idle" , "release"]:
            target = "call"
        if target == "phone":
            if ( dbus_object.gsm_device_obj is not None ) and dbus_object.gsm_network_iface.GetStatus()["registration"] == 'unregistered':
                try:
                    dbus_object.gsm_device_iface.SetAntennaPower(True)
                    dbus_object.gsm_network_iface.Register()
                except DBusException, e:
                    # TODO handle this better
                    print e
                    try:
                        authstatus = dbus_object.gsm_sim_iface.GetAuthStatus()
                        if authstatus == "SIM PUK":
                            target = "puk"
                        elif authstatus == "SIM PIN":
                            target = "pin"
                    except DBusException, e:
                        print e

        self.main.transition_to(target)

#----------------------------------------------------------------------------#
class pyphone_phone(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "phone")
        self.text = []

    @edje.decorators.signal_callback("dialer_button_pressed", "*")
    def on_edje_signal_dialer_button_pressed(self, emission, source):
        if "button_" in source:
            key = source.split("_", 1)[1]
            if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "#"):
                self.text.append(key)
                # The trailing whitespace is a workaround for the one char invisible
                # bug due to some problems with scaling of text parts.
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "star":
                self.text.append("*")
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "delete":
                self.text = self.text[:-1]
                self.part_text_set("label", "".join(self.text)+" ")
            elif key in "dial":
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_call_iface.Initiate( "".join(self.text), "voice" )
                else:
                    # Fake onCallStatus...
                    self.main.groups["call"].onCallStatus( None, "outgoing", {"peer": "".join(self.text)} )
        else:
            key = source
        #self.text.append(source)
        #self.part_text_set("label", "".join(self.text))

#----------------------------------------------------------------------------#
class pyphone_call(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "call")
        self.update_status("idle")
        self.call = None

    def onCallStatus( self, id, status, properties ):
        self.call = id
        self.update_status(status)
        try:
            self.part_text_set( "label", properties[ "peer" ] )
        except KeyError:
            pass

    @edje.decorators.signal_callback("call_button_pressed", "button_left")
    def on_edje_signal_call_button_left_pressed(self, emission, source):
        if self.status == "active":
            if dbus_object.gsm_device_obj:
                #dbus_object.gsm_call_iface.Hold(self.call)
                pass
            else:
                self.update_status("held")
        elif self.status in ["incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Activate(self.call)
            else:
                self.update_status("active")

    @edje.decorators.signal_callback("call_button_pressed", "button_right")
    def on_edje_signal_call_button_right_pressed(self, emission, source):
        if self.status in ["outgoing", "active", "incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Release(self.call)
            else:
                self.update_status("release")

    def update_status(self, status):
        self.part_text_set( "label_description", status )
        if status == "outgoing":
            self.part_text_set( "label_left", "" )
            self.part_text_set( "label_right", "cancel" )
        elif status == "active":
            self.part_text_set( "label_left", "hold" )
            self.part_text_set( "label_right", "hangup" )
        elif status == "incoming":
            self.part_text_set( "label_left", "answer" )
            self.part_text_set( "label_right", "reject" )
        elif status == "held":
            self.part_text_set( "label_left", "resume" )
            self.part_text_set( "label_right", "hangup" )
        else:
            self.part_text_set( "label_left", "" )
            self.part_text_set( "label_right", "" )
        if status in ["incoming", "outgoing"] and not self.status == status:
            # TODO make sure we get displayed
            if not self.main.in_transition:
                self.main.transition_to("call")
        self.status = status

#----------------------------------------------------------------------------#
class pyphone_contacts(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "contacts")
        self.ready = False
        self.busy = False
        self.phonebook = []
        self.current = []
        self.page = 0
        self.selected = None

    def cbNameEdit( self, name, reference ):
        print ( name, reference)
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                self.phonebook[i] = ( reference, name, self.phonebook[i][2] )
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_sim_iface.StoreEntry(
                        reference,
                        name,
                        self.phonebook[i][2]
                    )
                break
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.updateList()

    def cbNumberEdit( self, number, reference ):
        print ( number, reference)
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                self.phonebook[i] = ( reference, self.phonebook[i][1], number )
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_sim_iface.StoreEntry(
                        reference,
                        self.phonebook[i][1],
                        number
                    )
                break
        self.updateList()

    def cbNew1( self, name, none ):
        self.main.groups["number_edit"].setup(
            "contacts",
            "", # number
            name, # title = new name
            name, # reference
            self.cbNew2
        )

    def cbNew2( self, number, name ):
        ids = [ x[0] for x in self.phonebook ]
        ids.sort()
        reference = None
        for i in range(1, 250):
            if not i in ids:
                reference = i
        if reference is None:
            return # no space?
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreEntry(
                reference,
                name,
                number
            )
        self.phonebook.append( ( str(reference), name, number ) )
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.updateList()

    def cbDelete( self, result, reference ):
        if result == "abort":
            return
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.DeleteEntry(
                reference
            )
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                del self.phonebook[i]
                break
        self.updateList()

    def cbMenu( self, result ):
        print result
        if result == "edit name":
    	    self.main.groups["text_edit"].setup(
                "contacts",
                self.current[self.selected][1], # name
                self.current[self.selected][2], # title = number
                self.current[self.selected][0], # reference
                self.cbNameEdit
            )
        elif result == "edit number":
    	    self.main.groups["number_edit"].setup(
                "contacts",
                self.current[self.selected][2], # number
                self.current[self.selected][1], # title = name
                self.current[self.selected][0], # reference
                self.cbNumberEdit
            )
        elif result == "new":
    	    self.main.groups["text_edit"].setup(
                "contacts",
                "", # name
                "new contact", # title
                None, # reference
                self.cbNew1
            )
        elif result == "delete":
    	    self.main.groups["error"].activate(
                "delete '%s'?" % self.current[self.selected][1],
                ("abort", "delete"),
                self.current[self.selected][0], # reference
                self.cbDelete
            )

    def cbPhonebookReply( self, result ):
        print "retrieved phonebook: ", result
        self.busy = False
        self.phonebook = result
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.ready = True
        self.updateList()

    def cbPhonebookError( self, e ):
        print "error while retrieving phonebook"
        self.busy = False

    def onShow( self ):
        if not self.ready and not self.busy:
            if dbus_object.gsm_device_obj:
                print "retrieving phonebook"
                dbus_object.gsm_sim_iface.RetrievePhonebook(
                    reply_handler=self.cbPhonebookReply,
                    error_handler=self.cbPhonebookError
                )
                self.busy = True
            else:
                # Fake phonebook...
                self.cbPhonebookReply( [
                    ('1', 'Kirk', '+023224433'),
                    ('2', 'Spock', '+034433463'),
                    ('3', 'McCoy', '+013244344'),
                    ('4', 'Scott', '+013244344'),
                    ('5', 'Uhura', '+013244344'),
                    ('6', 'Sulu', '+013244344'),
                    ('7', 'Chekov', '+013244344'),
                ] )

    def updateList( self):
        if self.page < 0:
            self.page = 0
        while len( self.phonebook ) <= ( self.page )*6:
            self.page -= 1
        self.current = self.phonebook[self.page*6:(self.page+1)*6]
        for i in range( 0, len( self.current ) ):
            self.part_text_set( "label_list_%i" % i, self.current[i][1] )
        for i in range( len( self.current ), 6):
            self.part_text_set( "label_list_%i" % i, "" )
        self.selected = None
        for i in range( 6 ):
            self.signal_emit( "deactivate_button_list_%i" % i, "" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if self.selected == id:
            return
        if self.selected is not None:
            self.signal_emit( "deactivate_button_list_%i" % self.selected, "" )
        self.signal_emit( "activate_button_list_%i" % id, "" )
        self.selected = id

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_left" )
    def on_edje_signal_button_action_left_pressed( self, emission, source ):
        self.page -= 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_right" )
    def on_edje_signal_button_action_right_pressed( self, emission, source ):
        self.page += 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_dial" )
    def on_edje_signal_button_action_dial_pressed( self, emission, source ):
        if self.selected is not None:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Initiate( self.current[self.selected][2], "voice" )
            else:
                # Fake onCallStatus...
                self.main.groups["call"].onCallStatus( None, "outgoing", {"peer": self.current[self.selected][2]} )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
    	self.main.groups["menu"].activate(("edit name", "edit number", "new", "delete"), self.cbMenu)

#----------------------------------------------------------------------------#
class pyphone_location( edje_group ):
#----------------------------------------------------------------------------#
    class SignalGraph( evas.ClippedSmartObject ):
        def __init__( self, *args, **kargs ):
            evas.ClippedSmartObject.__init__( self, *args, **kargs )
            self.textheight = 45
            self.font = ( "Sans", 35 )
            self.children = []
            self.values = []
            self.maxvalue = None
            self.update( [(1, 20.5), (2, 34.3), (5, 25.9), (10, 0.5)] )

        def resize( self, w, h ):
            x, y = self.pos
            barwidth = w / len( self.children )
            barheight = h - self.textheight
            for (rect, key_text, value_text), (key, value) in zip( self.children, self.values ):
                key_text.text = str( key )
                value_text.text = str( value )
                barlength = int( barheight*( value/self.maxvalue ) )
                valueoffset = max( self.textheight-barlength, 0 )
                rect.geometry = (
                    x+5, y+barheight-barlength,
                    barwidth-5, barlength
                )
                key_text.geometry = (
                    x+(barwidth-key_text.horiz_advance)/2, y+barheight,
                    barwidth, self.textheight
                )
                value_text.geometry = (
                    x+(barwidth-value_text.horiz_advance)/2, y+5+barheight-barlength-valueoffset,
                    barwidth, self.textheight
                )
                x += barwidth

        def addChild( self ):
            rect = self.Rectangle( color=( 0, 255, 0, 255 ) )
            rect.show()
            key_text = self.Text(
                style = evas.EVAS_TEXT_STYLE_SOFT_OUTLINE,
                outline_color = ( 0, 0, 0, 255 ),
                font = self.font
            )
            key_text.show()
            value_text = self.Text(
                style = evas.EVAS_TEXT_STYLE_SOFT_OUTLINE,
                outline_color = ( 0, 0, 0, 255 ),
                font = self.font
            )
            value_text.show()
            self.children.append( ( rect, key_text, value_text ) )

        def delChild( self ):
            child = self.children[-1]
            del self.children[-1]
            for x in child:
                self.member_del( x )

        def update( self, values = None ):
            if values is not None:
                self.values = values
                self.maxvalue = max( [ x[1] for x in values] )
            while len( self.children ) > len( self.values ):
                self.delChild()
            while len( self.children ) < len( self.values ):
                self.addChild()
            self.resize( *self.size )

    def __init__(self, main):
        edje_group.__init__( self, main, "location" )
        self.signalgraph = self.SignalGraph( self.evas )

        self.page = "right"
        self.signal_emit( "activate_button_select_%s" % self.page, "" )

        self.accuracy = None
        self.position = None
        self.update()

    def update( self ):
        text = []
        if self.position:
            text.append( "Lat:<tab>%s<br>Lon:<tab>%s<br>Alt:<tab>%s" % self.position )
        else:
            text.append( "Lat:<tab>N/A<br>Lon:<tab>N/A<br>Alt:<tab>N/A" )
        if self.accuracy:
            text.append( "P/H/V-DOP:<tab>%s/%s/%s" % self.accuracy )
        else:
            text.append( "P/H/V-DOP:<tab>N/A")
        if self.page == "left":
            self.part_text_set( "status", "<br>".join( text ) )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
        elif self.page == "middle":
            self.part_text_set( "status", "" )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
            self.part_swallow( "swallow", self.signalgraph )
            self.signalgraph.show()
        elif self.page == "right":
            self.part_text_set( "status", "" )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )

    def onAccuracyChanged( self, fields, pdop, hdop, vdop ):
        self.accuracy = ( pdop, hdop, vdop )
        self.update()

    def onPositionChanged( self, fields, timestamp, lat, lon, alt ):
        self.position = ( lat, lon, alt )
        self.update()

    def onShow( self ):
        if dbus_object.usage_obj:
            dbus_object.usage_iface.RequestResource("GPS")
        self.update()

    def onHide( self ):
        if dbus_object.usage_obj:
            dbus_object.usage_iface.ReleaseResource("GPS")

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_select_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        self.page = source.split( "_" )[-1]
        self.signal_emit( "deactivate_button_select_left", "" )
        self.signal_emit( "deactivate_button_select_middle", "" )
        self.signal_emit( "deactivate_button_select_right", "" )
        self.signal_emit( "activate_button_select_%s" % self.page, "" )
        self.update()

#----------------------------------------------------------------------------#
class pyphone_sms(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "sms")
        self.text = []
        self.button_labels2 = [
            [
                [".,?!", "abc", "def", ""],
                ["ghi", "jkl", "mno", ""],
                ["pqrs", "tuv", "wxyz", ""],
                ["", "", "⇦⇧⇨", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.button_labels = [
            [
                ["1", "2", "3", "↤"],
                ["4", "5", "6", "↲"],
                ["7", "8", "9", "Abc"],
                ["+", "0", "⇩", "+"],
            ],
            [
                ["1", "?", "", ""],
                [".", ",", "", ""],
                ["!", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "2", "c", ""],
                ["", "a", "b", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "3", "f"],
                ["", "", "d", "e"],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", "↤"],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["4", "i", "", ""],
                ["g", "h", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "5", "l", ""],
                ["", "j", "k", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "6", "o"],
                ["", "", "m", "n"],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "s", "", ""],
                ["7", "r", "", ""],
                ["p", "q", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "8", "v", ""],
                ["", "t", "u", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", "z"],
                ["", "", "9", "y"],
                ["", "", "w", "x"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", " ", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "⇧", ""],
                ["", "⇦", "⇩", "⇨"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.set_button_text(0)
        self.active = 0

    @edje.decorators.signal_callback("kb_button_mouse_up", "*")
    def on_edje_signal_dialer_button_mouse_up(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        key = self.button_labels[self.active][y][x]
        self.text.append(key)
        # The trailing whitespace is a workaround for the one char invisible
        # bug due to some problems with scaling of text parts.
        self.part_text_set("label", "".join(self.text)+" ")
        self.set_button_text(0)
        print "mouse up:", time.time()-now

    @edje.decorators.signal_callback("kb_button_mouse_down", "*")
    def on_edje_signal_dialer_button_mouse_down(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        num = 4*y+x+1
        if self.active == 0:
            self.set_button_text(num)
        print "mouse down:", time.time()-now

    @edje.decorators.signal_callback("kb_mutton_mouse_in", "*")
    def on_edje_signal_dialer_button_mouse_in(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        self.part_text_set("label_preview", self.button_labels[self.active][y][x])
        print "mouse in:", time.time()-now

    def set_button_text(self, num):
        for i in xrange(4):
            for j in xrange(4):
                self.part_text_set("label_%d_%d" % (i,j) , self.button_labels[num][j][i])
        self.active = num

        if num != 0:
            num = 1

        for i in xrange(4):
            for j in xrange(4):
                self.part_text_set("label2_%d_%d" % (i,j) , self.button_labels2[num][j][i])

#----------------------------------------------------------------------------#
class pyphone_pin(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "pin")
        self.part_text_set( "label_description", "SIM PIN?" )
        self.text = []

    @edje.decorators.signal_callback("pin_button_pressed", "*")
    def on_edje_signal_pin_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "done":
            if dbus_object.gsm_device_obj:
                try:
                    self.part_text_set( "label_description", "Sending..." )
                    dbus_object.gsm_sim_iface.SendAuthCode("".join(self.text))
                except DBusException, e:
                    try:
                        authstatus = dbus_object.gsm_sim_iface.GetAuthStatus()
                        if authstatus == "SIM PUK":
                            self.main.transition_to("puk")
                        elif authstatus == "SIM PIN":
                            self.part_text_set( "label_description", "Invalid. SIM PIN?" )
                    except DBusException, e:
                        print e
                else:
                    self.part_text_set("label", "")
                    dbus_object.gsm_device_iface.SetAntennaPower(True)
                    dbus_object.gsm_network_iface.Register()
                    self.main.transition_to("main")

#----------------------------------------------------------------------------#
class pyphone_puk(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "puk")
        self.part_text_set( "label_description", "SIM PUK?" )
        self.text = []
        self.puk = []

    @edje.decorators.signal_callback("pin_button_pressed", "*")
    def on_edje_signal_puk_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "done":
            if self.puk == []:
              self.part_text_set( "label_description", "New PIN?" )
              self.puk = self.text
              self.text = []
            elif dbus_object.gsm_device_obj:
                try:
                    self.part_text_set( "label_description", "Sending..." )
                    dbus_object.gsm_sim_iface.Unlock("".join(self.puk), "".join(self.text))
                except DBusException, e:
                    print e
                    self.part_text_set( "label_description", "Invalid. SIM PUK?" )
                else:
                    self.part_text_set("label", "")
                    self.text = []
                    self.puk = []
                    dbus_object.gsm_device_iface.SetAntennaPower(True)
                    dbus_object.gsm_network_iface.Register()
                    self.main.transition_to("main")

#----------------------------------------------------------------------------#
class pyphone_number_edit( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "number_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key in ( "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "#" ):
            self.text += key
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set( "label", " %s " % self.text )
        elif key in "star":
            self.text += "*"
            self.part_text_set( "label", " %s " % self.text )
        elif key in "hash":
            self.text += "#"
            self.part_text_set( "label", " %s " % self.text )
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set( "label", " %s " % self.text )
        elif key in "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
    
    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", " %s " % self.title )
        self.part_text_set( "label", " %s " % self.text )
        self.main.transition_to("number_edit")

#----------------------------------------------------------------------------#
class pyphone_text_edit( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "text_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None
        self.shift_down = False

    def onShow( self ):
        self.focus = True
        if illume:
            illume.kbd_show()

    def onHide( self ):
        self.focus = False
        if illume:
            illume.kbd_hide()

    @evas.decorators.key_down_callback
    def on_key_down( self, event ):
        key = event.string
        if key == "\x08":
            self.text = self.text[:-1]
        elif key is not None:
            self.text += key
        self.part_text_set( "label", self.text )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key == "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
        elif key == "cancel":
            self.main.transition_to(self.parent_name)
    
    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", " %s " % self.title )
        self.part_text_set( "label", self.text )
        self.main.transition_to("text_edit")

#----------------------------------------------------------------------------#
class pyphone_menu( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "menu" )
        self.buttons = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_*" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        if source == "target_cancel":
            self.deactivate()
            self.cb( "cancel" )
        else:
            id = int( source.split( "_", 1 )[1] )
            self.deactivate()
            self.cb( self.part_text_get( "target_label_%i" % id ) )

    def activate( self, buttons, cb ):
        self.buttons = buttons
        self.cb = cb
        count = len( buttons )
        assert count == 4
        self.part_text_set( "target_label_0", buttons[0] )
        self.part_text_set( "target_label_1", buttons[1] )
        self.part_text_set( "target_label_2", buttons[2] )
        self.part_text_set( "target_label_3", buttons[3] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )


#----------------------------------------------------------------------------#
class pyphone_lock( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "lock" )
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "target_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        if id == self.step+1: # correct button
            self.signal_emit( "activate_%i" % id, "" )
            self.step += 1
        else:
            for id in range( 1, 5 ):
                self.signal_emit( "deactivate_%i" % id, "" )
            self.step = 0
        if self.step == 4:
            self.signal_emit( "invisible", "" )

    def activate( self ):
        self.step = 0
        for id in range( 1, 5 ):
            self.signal_emit( "deactivate_%i" % id, "" )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class pyphone_error( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "error" )
        self.buttons = None
        self.cb_data = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        self.deactivate()
        self.cb( self.part_text_get( "label_%i" % id ), self.cb_data )

    def activate( self, description, buttons, cb_data, cb ):
        self.buttons = buttons
        self.cb_data = cb_data
        self.cb = cb
        count = len( buttons )
        assert 1 <= count <= 3
        self.part_text_set( "description", description )
        if count == 1:
            self.signal_emit( "hide_0", "" )
            self.part_text_set( "label_0", "" )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[0] )
            self.signal_emit( "hide_2", "" )
            self.part_text_set( "label_2", "" )
        elif count == 2:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "hide_1", "" )
            self.part_text_set( "label_1", "" )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[1] )
        elif count == 3:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[1] )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[2] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class GUI(object):
#----------------------------------------------------------------------------#
    def __init__( self, options, args ):

        edje.frametime_set(1.0 / options.fps)

        self.evas_canvas = EvasCanvas(
            fullscreen = options.fullscreen,
            engine = options.engine,
            size = options.geometry
        )

        self.groups = {}

        self.groups["swallow"] = edje_group(self, "swallow")
        self.evas_canvas.evas_obj.data["swallow"] = self.groups["swallow"]

        for page in ( "main", "phone", "call", "sms", "contacts", "location", "pin", "puk", "number_edit", "text_edit" ):
            ctor = globals().get( "pyphone_%s" % page, None )
            if ctor:
                self.groups[page] = ctor( self )
                self.evas_canvas.evas_obj.data[page] = self.groups[page]

        for overlay in ( "menu", "lock", "error" ):
            ctor = globals().get( "pyphone_%s" % overlay, None )
            if ctor:
                self.groups[overlay] = ctor( self )
                self.evas_canvas.evas_obj.data[overlay] = self.groups[overlay]
                self.groups["swallow"].part_swallow( overlay, self.groups[overlay] )

        self.groups["swallow"].show()

        self.groups["swallow"].part_text_set("label_top_left", "zhone!")

        self.groups["swallow"].message_send(1, 0.0) # GSM signal strength
        self.groups["swallow"].message_send(2, 0.0) # battery charge

        self.groups["swallow"].part_swallow("swallow2", self.groups["main"])
        self.current_group = self.groups["main"]
        self.previous_group = self.groups["phone"]
        self.in_transition = False
        ecore.timer_add(60.0, self.display_time)
        self.display_time()

        self.groups["swallow"].part_text_set( "label_top_right", "no dbus" )
        ecore.idle_enterer_add( self.dbus_objectInit )

    def run( self ):
        ecore.main_loop_begin()

    def shutdown( self ):
        ecore.main_loop_quit()

    def dbus_objectInit( self ):
        print "dbus_objectInit..."
        global dbus_object
        if dbus_object is None:
            dbus_object = DBusObject()
        if not dbus_object.initialize():
            # try again later
            ecore.timer_add( 10.0, self.dbus_objectInit )
            return False
        else:
            self.dbus_objectInitOK()
        return False

    def dbus_objectInitOK( self ):
        print "dbus_objectInitOK!"
        if dbus_object.usage_obj is not None:
            dbus_object.onResourceChanged.append(self.display_resources)
            self.display_resources()

        if dbus_object.gps_obj:
            dbus_object.onAccuracyChanged.append( self.groups["location"].onAccuracyChanged )
            dbus_object.onPositionChanged.append( self.groups["location"].onPositionChanged )

        if dbus_object.gsm_device_obj is not None:
            dbus_object.onCallStatus.append( self.groups["call"].onCallStatus )
            dbus_object.onNetworkStatus.append(self.update_network)
            try:
                dbus_object.gsm_device_iface.SetAntennaPower(True)
                dbus_object.gsm_network_iface.Register()
            except DBusException, e:
                # TODO handle this better
                print e
                try:
                    authstatus = dbus_object.gsm_sim_iface.GetAuthStatus()
                    if authstatus == "SIM PUK":
                        self.transition_to("puk")
                    elif authstatus == "SIM PIN":
                        self.transition_to("pin")
                except DBusException, e:
                    print e

        if dbus_object.idlenotifier_iface is not None:
            dbus_object.onIdleStateChanged.append(self.lock_on_idle)

        if dbus_object.device_power_iface is not None:
            # Update Battery charge as soon as we have DBus
            batcharge = dbus_object.device_power_iface.GetEnergyPercentage()
            self.groups["swallow"].message_send(2, batcharge/100.0) # battery charge

        if options.start:
            self.transition_to(options.start)

    def lock_on_idle( self, state ):
        if state == "LOCK":
            self.groups["lock"].activate()

    def display_time(self):
        self.groups["main"].part_text_set("label", time.strftime("%H:%M", time.localtime()))
        self.groups["swallow"].part_text_set("label_top_center", time.strftime("%Y-%m-%d", time.localtime()))
        if ( dbus_object is not None ) and ( dbus_object.device_power_iface is not None ):
            batcharge = dbus_object.device_power_iface.GetEnergyPercentage()
            self.groups["swallow"].message_send(2, batcharge/100.0) # battery charge
        return True

    def display_resources( self, **args ):
        items = []
        names = {
            "GSM": "G",
            "WiFi": "W",
            "GPS": "S",
            "Bluetooth": "B",
        }
        for resourcename in dbus_object.usage_iface.ListResources():
            if dbus_object.usage_iface.GetResourceState( resourcename ):
                users = dbus_object.usage_iface.GetResourceUsers( resourcename )
                items.append( "%s%s" % ( names[resourcename], len( users ) ) )
            else:
                items.append( "%s" % ( names[resourcename].lower() ) )
            policy = dbus_object.usage_iface.GetResourcePolicy( resourcename )
            if policy == 'enabled':
                items[-1] = "+" + items[-1]
                continue
            elif policy == 'disabled':
                items[-1] = "-" + items[-1]
                continue
        self.groups["swallow"].part_text_set( "label_top_right", " ".join( items ) )

    def update_network( self, **args):
        status = args["status"]
        self.groups["swallow"].message_send(1, status["strength"]/100.0)
        if status["registration"] == "denied":
            self.groups["swallow"].part_text_set("label_top_left", "SOS only")
        elif status["registration"] == "unregistered":
            self.groups["swallow"].part_text_set("label_top_left", "No Service")
        elif status["registration"] == "busy":
            self.groups["swallow"].part_text_set("label_top_left", "Searching...")
        elif status["registration"] == "unknown":
            self.groups["swallow"].part_text_set("label_top_left", "[Unknown]")
        else:
            self.groups["swallow"].part_text_set("label_top_left", status["provider"])

    # TODO better state management for transitions
    def transition_to(self, target):
        if self.current_group == self.groups[target]:
            return
        print "transition to", target
        self.in_transition = True

        self.previous_group = self.current_group

        self.current_group = self.groups[target]
        self.current_group.onShow()
        self.current_group.signal_emit("visible", "")
        self.groups["swallow"].part_swallow("swallow1", self.current_group)
        self.previous_group.signal_emit("fadeout", "")

    def transition_finished(self):
        print "finished"
        self.previous_group.onHide()
        self.previous_group.hide()
        self.groups["swallow"].part_swallow("swallow2", self.current_group)
        self.in_transition = False

#----------------------------------------------------------------------------#
class EvasCanvas(object):
#----------------------------------------------------------------------------#
    def __init__(self, fullscreen, engine, size):
        if engine == "x11":
            f = ecore.evas.SoftwareX11
        elif engine == "x11-16":
            if ecore.evas.engine_type_supported_get("software_x11_16"):
                f = ecore.evas.SoftwareX11_16
            else:
                print "warning: x11-16 is not supported, fallback to x11"
                f = ecore.evas.SoftwareX11

        self.evas_obj = f(w=size[0], h=size[1])
        self.evas_obj.callback_delete_request = self.on_delete_request
        self.evas_obj.callback_resize = self.on_resize

        self.evas_obj.title = TITLE
        self.evas_obj.name_class = (WM_NAME, WM_CLASS)
        self.evas_obj.fullscreen = fullscreen
        self.evas_obj.size = size
        self.evas_obj.evas.image_cache_set( 6*1024*1024 )
        self.evas_obj.evas.font_cache_set( 2*1024*1024 )
        self.evas_obj.show()

    def on_resize(self, evas_obj):
        x, y, w, h = evas_obj.evas.viewport
        size = (w, h)
        evas_obj.data["swallow"].size = size

    def on_delete_request(self, evas_obj):
        ecore.main_loop_quit()

#----------------------------------------------------------------------------#
class MyOptionParser(OptionParser):
#----------------------------------------------------------------------------#
    def __init__(self):
        OptionParser.__init__(self)
        self.set_defaults(fullscreen = False)
        self.add_option("-e",
                      "--engine",
                      type="choice",
                      choices=("x11", "x11-16"),
                      default="x11-16",
                      help=("which display engine to use (x11, x11-16), "
                            "default=%default"))
        self.add_option("--fullscreen",
                      action="store_true",
                      dest="fullscreen",
                      help="launch in fullscreen")
        self.add_option("--no-fullscreen",
                      action="store_false",
                      dest="fullscreen",
                      help="launch in a window")
        self.add_option("-g",
                      "--geometry",
                      type="string",
                      metavar="WxH",
                      action="callback",
                      callback=self.parse_geometry,
                      default=(WIDTH, HEIGHT),
                      help="use given window geometry")
        self.add_option("-f",
                      "--fps",
                      type="int",
                      default=20,
                      help="frames per second to use, default=%default")
        self.add_option("-s",
                      "--start",
                      type="string",
                      default=None,
                      help="start with the given page")

    def parse_geometry(option, opt, value, parser):
        try:
            w, h = value.split("x")
            w = int(w)
            h = int(h)
        except Exception, e:
            raise optparse.OptionValueError("Invalid format for %s" % option)
        parser.values.geometry = (w, h)

#----------------------------------------------------------------------------#
class DBusObject( object ):
#----------------------------------------------------------------------------#
    def __init__( self ):
        self.objects = {}
        self.onResourceChanged = []
        self.onAccuracyChanged = []
        self.onPositionChanged = []
        self.onCallStatus = []
        self.onNetworkStatus = []
        self.onIdleStateChanged = []
        self.ignoreSuspend = False

        self.framework_obj = None

        self.usage_obj = None
        self.usage_iface = None

        self.gps_obj = None
        self.gps_accuracy_iface = None
        self.gps_position_iface = None

        self.gsm_device_obj = None
        self.gsm_device_iface = None
        self.device_iface = None
        self.device_power_iface = None
        self.idlenotifier_obj = None
        self.idlenotifier_iface = None
        self.inputnotifier_obj = None
        self.inputnotifier_iface = None
        self.display_obj = None
        self.display_iface = None

        self.fullinit = False

    def tryGetProxy( self, busname, objname ):
        object = None
        try:
            object = self.objects[ "%s:%s" % ( busname, objname ) ]
        except KeyError:
            try:
                object = self.bus.get_object( busname, objname )
            except DBusException, e:
                print "could not create proxy for %s:%s" % ( busname, objname ), e
            else:
                self.objects[ "%s:%s" % ( busname, objname ) ] = object
        return object

    def initialize( self ):
        if self.fullinit:
            return True
        try:
            self.bus = SystemBus( mainloop=e_dbus.DBusEcoreMainLoop() )
        except DBusException, e:
            print "could not connect to dbus_object system bus:", e
            return False

        # Framework
        fw_obj = self.tryGetProxy( 'org.freesmartphone.frameworkd', '/org/freesmartphone/Framework' )
        if fw_obj is None:
            print ( "could not connect to org.freesmartphone.frameworkd -- is the framework daemon started?" )
            return False
        else:
            self.fw = Interface( fw_obj, "org.freesmartphone.Objects" )
        failcount = 0

        # Usage
        self.usage_obj = self.tryGetProxy( 'org.freesmartphone.ousaged', '/org/freesmartphone/Usage' )
        if ( self.usage_obj is not None ) and ( self.usage_iface is None ):
            self.usage_iface = Interface(self.usage_obj, 'org.freesmartphone.Usage')
            self.usage_iface.connect_to_signal( "ResourceChanged", self.cbResourceChanged )
            self.usage_iface.RequestResource("GSM")
        if self.usage_obj is None:
            failcount += 1
        else:
            print "usage ok", self.usage_iface

        # GPS
        self.gps_obj = self.tryGetProxy( 'org.freesmartphone.ogpsd', '/org/freedesktop/Gypsy' )
        if self.gps_obj and not self.gps_accuracy_iface:
            self.gps_accuracy_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Accuracy')
            self.gps_accuracy_iface.connect_to_signal( "AccuracyChanged", self.cbAccuracyChanged )
        if self.gps_obj and not self.gps_position_iface:
            self.gps_position_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Position')
            self.gps_position_iface.connect_to_signal( "PositionChanged", self.cbPositionChanged )
        if not self.gps_obj or not self.gps_accuracy_iface or not self.gps_position_iface:
            failcount += 1
        else:
            print "gps ok", self.gps_accuracy_iface, self.gps_position_iface

        # Phone
        self.gsm_device_obj = self.tryGetProxy( 'org.freesmartphone.ogsmd', '/org/freesmartphone/GSM/Device' )
        print self.gsm_device_obj

        if ( self.gsm_device_obj is not None ) and ( self.gsm_device_iface is None ):
            print "creating gsm interfaces"
            self.gsm_device_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Device')
            self.gsm_sim_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.SIM')
            self.gsm_network_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Network')
            self.gsm_call_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Call')
            self.gsm_test_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Test')
            self.gsm_call_iface.connect_to_signal( "CallStatus", self.cbCallStatus )
            self.gsm_network_iface.connect_to_signal( "Status", self.cbNetworkStatus )
        if self.gsm_device_obj is None:
            failcount += 1
        else:
            print "gsm ok", self.gsm_network_iface

        self.device_obj = self.tryGetProxy( 'org.freesmartphone.odeviced', '/org/freesmartphone/Device' )
        if ( self.device_obj is not None ) and ( self.device_iface is None ):
            self.device_iface = Interface( self.device_obj, 'org.freesmartphone.Device' )

            self.device_power_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.PowerSupply" )[0] )
            self.device_power_iface = Interface(self.device_power_obj, 'org.freesmartphone.Device.PowerSupply')

            self.idlenotifier_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.IdleNotifier" )[0] )

            self.idlenotifier_iface = Interface( self.idlenotifier_obj, "org.freesmartphone.Device.IdleNotifier" )
            self.idlenotifier_iface.connect_to_signal( "State", self.cbIdleStateChanged )

            self.inputnotifier_obj = self.bus.get_object( "org.freesmartphone.odeviced", "/org/freesmartphone/Device/Input" )
            self.inputnotifier_iface = Interface( self.inputnotifier_obj, "org.freesmartphone.Device.Input" )
            self.inputnotifier_iface.connect_to_signal( "Event", self.cbEvent )

            print "displays:", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.Display" )
            self.display_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.Display" )[0] )
            if self.display_obj is not None:
                self.display_iface = Interface( self.display_obj, "org.freesmartphone.Device.Display" )
                self.display_iface.SetBrightness( 90 )
        if self.device_obj is None:
            failcount += 1
        else:
            print "device ok", self.device_iface

        print "failcount=", failcount
        if failcount == 0:
            self.fullinit = True
        return self.fullinit

    def cbResourceChanged( self, resourcename ):
        for cb in self.onResourceChanged:
            cb( resourcename=resourcename )

    def cbAccuracyChanged( self, fields, pdop, hdop, vdop ):
        for cb in self.onAccuracyChanged:
            cb( fields=fields, pdop=pdop, hdop=hdop, vdop=vdop )

    def cbPositionChanged( self, fields, timestamp, lat, lon, alt ):
        for cb in self.onPositionChanged:
            cb( fields=fields, timestamp=timestamp, lat=lat, lon=lon, alt=alt )

    def cbCallStatus( self, id, status, properties ):
        print "CALL STATUS=", id, status, properties
        if self.idlenotifier_iface is not None:
            self.idlenotifier_iface.SetState("BUSY")
        for cb in self.onCallStatus:
            cb( id=id, status=status, properties=properties )

    def cbNetworkStatus( self, status ):
        for cb in self.onNetworkStatus:
            cb( status=status )

    def cbIdleStateChanged( self, state ):
        print "IDLE STATE=", state
        for cb in self.onIdleStateChanged:
            cb( state=state )
        if state == "BUSY":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 90 )
        elif state == "IDLE_DIM":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 20 )
        elif state == "IDLE_PRELOCK":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 0 )

    def cbEvent( self, name, action, seconds ):
        print "INPUT EVENT=", name, action, seconds
        if name+action == "AUXpressed":
            # FIXME launch transition to main screen
            pass
        elif name+action == "POWERpressed":
            # FIXME should the kernel filter out the button event that triggerd the wakeup?
            if self.ignoreSuspend: # we've just resumed
                self.ignoreSuspend = False
                return
            self.ignoreSuspend = True
            self.gsm_device_iface.PrepareForSuspend()
            print "ENTERING SUSPEND"
            os.system( "apm -s" )
            print "RETURN FROM SUSPEND"
            self.gsm_device_iface.RecoverFromSuspend()
            self.idlenotifier_iface.SetState("BUSY")

if __name__ == "__main__":

    options, args = MyOptionParser().parse_args()
    dbus_object = None
    gui = GUI( options, args )
    try:
        gui.run()
    except KeyboardInterrupt:
        gui.shutdown()
        del gui
