#!/usr/bin/env python
#coding=utf8
"""
Zen Phone - A Phone UI

(C) 2007 Johannes 'Josch' Schauer
(C) 2008 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
(C) 2008 Jan 'Shoragan' Luebbe
(C) 2008 Daniel 'Alphaone' Willmann
(C) 2008 Openmoko, Inc.
GPLv2 or later
"""

import logging
logger = logging.getLogger( "zhone" )
logger.setLevel( logging.DEBUG )
logging.basicConfig( level    = logging.DEBUG,
                    format   = '%(asctime)s %(levelname)s %(message)s',
                    filename = '/tmp/zhone.log',
                    filemode = 'w' )

#----------------------------------------------------------------------------#
WIDTH = 480
HEIGHT = 640

TITLE = "zhone"
WM_NAME = "zhone"
WM_CLASS = "zhone"

#----------------------------------------------------------------------------#
import os
import sys
import e_dbus
import evas
import evas.decorators
import edje
import edje.decorators
import ecore
import ecore.evas
import cairo
from dbus import SystemBus, Interface
from dbus.exceptions import DBusException
from optparse import OptionParser
import time
import math

illume = None
try:
    import illume
except ImportError:
    logger.warning( "could not load illume interface module" )

#----------------------------------------------------------------------------#

edjepaths = "../data/themes/zhone.edj ../share/zhone.edj /usr/local/share/zhone/zhone.edj /usr/share/zhone/zhone.edj".split()

for i in edjepaths:
    if os.path.exists( i ):
       global edjepath
       edjepath = i
       break
else:
    raise Exception( "zhone.edj not found. looked in %s" % edjepaths )

#----------------------------------------------------------------------------#
class edje_group(edje.Edje):
#----------------------------------------------------------------------------#
    def __init__(self, main, group, parent_name="main"):
        self.main = main
        self.parent_name = parent_name
        self.group = group
        global edjepath
        f = edjepath
        try:
            edje.Edje.__init__(self, self.main.evas_canvas.evas_obj.evas, file=f, group=group)
        except edje.EdjeLoadError, e:
            raise SystemExit("error loading %s: %s" % (f, e))
        self.size = self.main.evas_canvas.evas_obj.evas.size

    def onShow( self ):
        pass

    def onHide( self ):
        pass

    @edje.decorators.signal_callback("mouse,clicked,1", "button_bottom_right")
    def on_edje_signal_button_bottom_right_pressed(self, emission, source):
        self.main.transition_to(self.parent_name)

    @edje.decorators.signal_callback("mouse,clicked,1", "button_bottom_left")
    def on_edje_signal_button_bottom_left_pressed(self, emission, source):
        self.main.groups["main_menu"].activate( self.group )
        self.main.transition_to("main_menu")

#----------------------------------------------------------------------------#
class pyphone_main(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "main")
        self.targets = {
            "phone": False,
            "contacts": False,
            "sms": False,
            "location": False,
            "configuration": True,
        }
        self.update()

    def update( self ):
        for key, value in self.targets.items():
            if value:
                self.signal_emit( "activate_target_icon_%s" % key, "" )
            else:
                self.signal_emit( "deactivate_target_icon_%s" % key, "" )

    @edje.decorators.signal_callback("mouse,clicked,1", "target_*")
    def on_edje_signal_button_pressed(self, emission, source):
        target = source.split('_', 1)[1]
        if not self.targets[target]:
            return
        if target == "phone" and not self.main.groups["call"].status in ["idle" , "release"]:
            target = "call"
        self.main.transition_to(target)

#----------------------------------------------------------------------------#
class pyphone_phone(edje_group):
#----------------------------------------------------------------------------#
    TIMEOUT = 2.0
    def __init__(self, main):
        edje_group.__init__(self, main, "phone")
        self.text = []
        self.last = 0.0

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_dialer_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", u"".join(self.text)+u" ")
        elif key in "star":
            if self.text and ( time.time()-self.last < self.TIMEOUT ):
                if self.text[-1] == "*":
                    del self.text[-1]
                    self.text.append( "+" )
                elif self.text[-1] == "+":
                    del self.text[-1]
                    self.text.append( "*" )
                else:
                    self.text.append( "*" )
            else:
                self.text.append("*")
            self.part_text_set( "label", u"".join(self.text)+u" " )
        elif key in "hash":
            self.text += "#"
            self.part_text_set( "label", u"".join(self.text)+u" " )
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", u"".join(self.text)+u" ")
        elif key in "dial":
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Initiate( "".join(self.text), "voice" )
            else:
                # Fake onCallStatus...
                self.main.groups["call"].onCallStatus( None, "outgoing", {"peer": "".join(self.text)} )
        self.last = time.time()

#----------------------------------------------------------------------------#
class pyphone_call(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "call")
        self.update_status("idle")
        self.call = None

    def onCallStatus( self, id, status, properties ):
        self.call = id
        self.update_status(status)
        try:
            self.part_text_set( "label", properties[ "peer" ] )
        except KeyError:
            pass

    @edje.decorators.signal_callback("call_button_pressed", "button_left")
    def on_edje_signal_call_button_left_pressed(self, emission, source):
        if self.status == "active":
            if dbus_object.gsm_device_obj:
                #dbus_object.gsm_call_iface.Hold(self.call)
                pass
            else:
                self.update_status("held")
        elif self.status in ["incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Activate(self.call)
            else:
                self.update_status("active")

    @edje.decorators.signal_callback("call_button_pressed", "button_right")
    def on_edje_signal_call_button_right_pressed(self, emission, source):
        if self.status in ["outgoing", "active", "incoming", "held"]:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Release(self.call)
            else:
                self.update_status("release")

    def update_status(self, status):
        self.part_text_set( "label_description", status )
        if status == "outgoing":
            self.part_text_set( "label_left", u"" )
            self.part_text_set( "label_right", u"cancel" )
        elif status == "active":
            self.part_text_set( "label_left", u"hold" )
            self.part_text_set( "label_right", u"hangup" )
        elif status == "incoming":
            self.part_text_set( "label_left", u"answer" )
            self.part_text_set( "label_right", u"reject" )
        elif status == "held":
            self.part_text_set( "label_left", u"resume" )
            self.part_text_set( "label_right", u"hangup" )
        else:
            self.part_text_set( "label_left", u"" )
            self.part_text_set( "label_right", u"" )
        if status in ["incoming", "outgoing"] and not self.status == status:
            # TODO make sure we get displayed
            self.main.transition_to("call")
        self.status = status

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.main.transition_to("dtmf")

#----------------------------------------------------------------------------#
class pyphone_dtmf(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "dtmf")
        self.text = []
        self.last = 0.0

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_dialer_button_pressed(self, emission, source):
        key = source.split("_", 1)[1]
        if key in ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"):
            self.text.append(key)
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "star":
            if self.text and ( time.time()-self.last < self.TIMEOUT ):
                if self.text[-1] == "*":
                    del self.text[-1]
                    self.text.append( "+" )
                elif self.text[-1] == "+":
                    del self.text[-1]
                    self.text.append( "*" )
                else:
                    self.text.append( "*" )
            else:
                self.text.append("*")
            self.part_text_set( "label", "".join(self.text)+" " )
        elif key in "hash":
            self.text += "#"
            self.part_text_set( "label", "".join(self.text)+" " )
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set("label", "".join(self.text)+" ")
        elif key in "dial":
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.SendDtmf( "".join(self.text))
                self.main.transition_to("call")

    @edje.decorators.signal_callback("call_button_pressed", "button_right")
    def on_edje_signal_call_button_right_pressed(self, emission, source):
        self.main.transition_to("call")


#----------------------------------------------------------------------------#
class pyphone_sms(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "sms")
        self.ready = False
        self.busy = False
        self.messagebook = []
        self.current = []
        self.page = 0
        self.selected = None

    def cbSendReply( self ):
        logger.info( "sent message" )

    def cbSendError( self, e ):
        logger.warning( "error while sending message" )

    def cbStoreReply( self, result ):
        logger.info( "stored message: %s" % result )
        if dbus_object.gsm_device_obj:
            logger.info( "trying to retrieve phonebook..." )
            dbus_object.gsm_sim_iface.SendStoredMessage(
                result,
                reply_handler=self.cbSendReply,
                error_handler=self.cbSendError
            )
        if not self.busy:
            dbus_object.gsm_sim_iface.RetrieveMessagebook(
                "all",
                reply_handler=self.cbMessagebookReply,
                error_handler=self.cbMessagebookError
            )
            self.busy = True

    def cbStoreError( self, e ):
        logger.warning( "error while storing message" )

    def cbSend1( self, selected, cb_data ):
        self.main.groups["text_edit"].setup(
            "sms",
            "", # text
            selected[0], # title
            selected[1], # reference
            self.cbSend2
        )

    def cbSend2( self, text, number ):
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreMessage(
                number, text,
                reply_handler=self.cbStoreReply,
                error_handler=self.cbStoreError
            )

    def cbDelete( self, result, reference ):
        if result == "abort":
            return
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.DeleteMessage(
                reference
            )
        for i in range( len( self.messagebook ) ):
            if self.messagebook[i][0] == reference:
                del self.messagebook[i]
                break
        self.updateList()

    def cbForward( self, selected, text ):
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreMessage(
                selected[1], text,
                reply_handler=self.cbStoreReply,
                error_handler=self.cbStoreError
            )

    def cbReply( self, text, number):
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreMessage(
                number, text,
                reply_handler=self.cbStoreReply,
                error_handler=self.cbStoreError
            )

    def cbMenu( self, result ):
        if result == "send":
            self.main.groups["contacts"].prepare()
            if self.main.groups["contacts"].ready:
                self.main.groups["list_choose"].setup(
                    "sms",
                    [ (x[1], x[2]) for x in  self.main.groups["contacts"].phonebook],
                    None,
                    self.cbSend1
                )
        elif result == "delete":
            self.main.groups["error"].activate(
                "delete?",
                ("abort", "delete"),
                self.current[self.selected][0], # reference
                self.cbDelete
            )
        elif result == "forward":
            self.main.groups["contacts"].prepare()
            if self.main.groups["contacts"].ready:
                self.main.groups["list_choose"].setup(
                    "sms",
                    [ (x[1], x[2] ) for x in  self.main.groups["contacts"].phonebook],
                    self.current[self.selected][3],
                    self.cbForward
                )
        elif result == "reply":
            self.main.groups["text_edit"].setup(
                "sms",
                "", # text
                self.current[self.selected][2], # title = number
                self.current[self.selected][2], # reference = number
                self.cbReply
            )

    def cbMessagebookReply( self, result ):
        logger.info( "retrieved messagebook: %s" % result )
        self.busy = False
        self.messagebook = result
        self.ready = True
        self.updateList()
        self.main.groups["main"].targets["sms"] = True
        self.main.groups["main"].update()

    def cbMessagebookError( self, e ):
        logger.warning( "error while retrieving messagebook" )
        self.busy = False

    def onIncomingMessage( self, index ):
        logger.info( "new message! Retrieving messagebook..." )
        if not self.busy:
            dbus_object.gsm_sim_iface.RetrieveMessagebook(
                "all",
                reply_handler=self.cbMessagebookReply,
                error_handler=self.cbMessagebookError
            )
            self.busy = True

    def prepare( self ):
        if not self.ready and not self.busy:
            if dbus_object.gsm_device_obj:
                logger.info( "retrieving messagebook..." )
                dbus_object.gsm_sim_iface.RetrieveMessagebook(
                    "all",
                    reply_handler=self.cbMessagebookReply,
                    error_handler=self.cbMessagebookError
                )
                self.busy = True
            else:
                # Fake messagebook...
                self.cbMessagebookReply( [
                    (0, "read", "+4544555", "Hello World!"),
                    (1, "read", "+456663443", "Zhone!"),
                    (2, "read", "+456663443", "Hi Guy\nGuess what, I now "+
                        "know to write multi-line SMSs.\nIsn't that "+
                        "nice?\n\nSome Buddy"),
                    (3, "read", "Flash SMS", "An SMS without digits. Strange, isn't it?"),
                ] )

    def onReadyStatus( self, status ):
        logger.debug( "SIM is ready: %s" % status )
        if status:
            # Force update
            self.ready = False
            self.prepare()

    def onShow( self ):
        self.prepare()
        self.updateList()

    def updateList( self):
        self.main.groups["contacts"].prepare()
        self.pages = max( ( len( self.messagebook ) - 1 ) / 6 + 1, 1 )
        if self.page >= self.pages:
            self.page = self.pages - 1
        if self.page < 0:
            self.page = 0
        self.current = self.messagebook[self.page*6:(self.page+1)*6]
        text = u"".join( [u"□"]*self.page+[u"▣"]+[u"□"]*(self.pages-self.page-1) )
        self.part_text_set( "pager", text )
        for i in range( 0, len( self.current ) ):
            main_text = self.main.groups["contacts"].tryNumberToName( self.current[i][2] )
            self.part_text_set( "label_main_list_%i" % i, main_text )
            sub_text = " ".join(self.current[i][3].splitlines())
            self.part_text_set( "label_sub_list_%i" % i, u"(%s) %s" % ( self.current[i][1], sub_text ) )
        for i in range( len( self.current ), 6):
            self.part_text_set( "label_main_list_%i" % i, u"" )
            self.part_text_set( "label_sub_list_%i" % i, u"" )
        self.selected = None
        for i in range( 6 ):
            self.signal_emit( "deactivate_target_list_%i" % i, "" )


    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if self.selected == id:
            return
        if self.selected is not None:
            self.signal_emit( "deactivate_target_list_%i" % self.selected, "" )
        self.signal_emit( "activate_target_list_%i" % id, "" )
        self.selected = id

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_left" )
    def on_edje_signal_button_action_left_pressed( self, emission, source ):
        self.page -= 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_right" )
    def on_edje_signal_button_action_right_pressed( self, emission, source ):
        self.page += 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_open" )
    def on_edje_signal_button_action_open_pressed( self, emission, source ):
        if self.selected is not None:
            from_text = self.main.groups["contacts"].tryNumberToName( self.current[self.selected][2] )
            self.main.groups["text_show"].setup(
                "sms",
                "From: %s<p>%s" % (
                    from_text,
                    self.current[self.selected][3].replace( '\n', '<br>' )
                )
            )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.main.groups["menu"].activate( ( "send", "delete", "forward", "reply" ), self.cbMenu )


#----------------------------------------------------------------------------#
class pyphone_configuration(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "configuration")
        self.selected = None
        self.profiles = []
        
    def onShow( self ):
        self.prepare()
        self.updateList()
        
    def prepare( self ):
        # Set the current profile label
        if dbus_object.prefs_obj:
            current = dbus_object.prefs_iface.GetProfile()
            self.profiles = dbus_object.prefs_iface.GetProfiles()
        else:
            current = 'Test1'
            self.profiles = ["Test1", "Test2"]
        self.part_text_set( "current_label", u"Current : %s" % current )

    def updateList( self):
        self.main.groups["configuration"].prepare()
        # We put all the profile names in the slots
        for i in range(6):
            if i < len(self.profiles):
                name = self.profiles[i]
            else:
                name = u""
            self.part_text_set( "label_main_list_%i" % i, name )
            self.part_text_set( "label_sub_list_%i" % i, u"" )
        self.selected = None
        for i in range( 6 ):
            self.signal_emit( "deactivate_target_list_%i" % i, "" )
        
    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if self.selected == id:
            return
        if self.selected is not None:
            self.signal_emit( "deactivate_target_list_%i" % self.selected, "" )
        self.signal_emit( "activate_target_list_%i" % id, "" )
        self.selected = id
        
    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_use" )
    def on_edje_signal_button_action_use_pressed( self, emission, source ):
        if self.selected is None:
            return
        if self.selected >= len(self.profiles):
            return
        profile = self.profiles[self.selected]
        self.part_text_set( "current_label", u"Current : %s" % profile )
        if dbus_object.prefs_obj:
            dbus_object.prefs_iface.SetProfile(profile)

#----------------------------------------------------------------------------#
class pyphone_contacts(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "contacts")
        self.ready = False
        self.busy = False
        self.phonebook = []
        self.current = []
        self.page = 0
        self.selected = None

    def cbNameEdit( self, name, reference ):
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                self.phonebook[i] = ( reference, name, self.phonebook[i][2] )
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_sim_iface.StoreEntry(
                        reference,
                        name,
                        self.phonebook[i][2]
                    )
                break
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.updateList()

    def cbNumberEdit( self, number, reference ):
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                self.phonebook[i] = ( reference, self.phonebook[i][1], number )
                if dbus_object.gsm_device_obj:
                    dbus_object.gsm_sim_iface.StoreEntry(
                        reference,
                        self.phonebook[i][1],
                        number
                    )
                break
        self.updateList()

    def cbNew1( self, name, none ):
        self.main.groups["number_edit"].setup(
            "contacts",
            "", # number
            name, # title = new name
            name, # reference
            self.cbNew2
        )

    def cbNew2( self, number, name ):
        ids = [ x[0] for x in self.phonebook ]
        ids.sort()
        reference = None
        for i in range(1, 250):
            if not i in ids:
                reference = i
                break
        if reference is None:
            return # no space?
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.StoreEntry(
                reference,
                name,
                number
            )
        self.phonebook.append( ( reference, name, number ) )
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.updateList()

    def cbDelete( self, result, reference ):
        if result == "abort":
            return
        if dbus_object.gsm_device_obj:
            dbus_object.gsm_sim_iface.DeleteEntry(
                reference
            )
        for i in range( len( self.phonebook ) ):
            if self.phonebook[i][0] == reference:
                del self.phonebook[i]
                break
        self.updateList()

    def cbMenu( self, result ):
        if result == "edit name":
            self.main.groups["text_edit"].setup(
                "contacts",
                self.current[self.selected][1], # name
                self.current[self.selected][2], # title = number
                self.current[self.selected][0], # reference
                self.cbNameEdit
            )
        elif result == "edit number":
            self.main.groups["number_edit"].setup(
                "contacts",
                self.current[self.selected][2], # number
                self.current[self.selected][1], # title = name
                self.current[self.selected][0], # reference
                self.cbNumberEdit
            )
        elif result == "new":
            self.main.groups["text_edit"].setup(
                "contacts",
                "", # name
                "name?", # title
                None, # reference
                self.cbNew1
            )
        elif result == "delete":
            self.main.groups["error"].activate(
                "delete '%s'?" % self.current[self.selected][1],
                ("abort", "delete"),
                self.current[self.selected][0], # reference
                self.cbDelete
            )

    def cbPhonebookReply( self, result ):
        logger.info( "retrieved phonebook: %s" % result )
        self.busy = False
        self.phonebook = result
        self.phonebook.sort( key = lambda x: x[1].lower() )
        self.ready = True
        self.updateList()
        self.main.groups["main"].targets["contacts"] = True
        self.main.groups["main"].update()

    def cbPhonebookError( self, e ):
        logger.error( "error while retrieving phonebook %s" % e )
        self.busy = False

    def prepare( self ):
        if not self.ready and not self.busy:
            if dbus_object.gsm_device_obj:
                logger.info( "retrieving phonebook..." )
                dbus_object.gsm_sim_iface.RetrievePhonebook(
                    reply_handler=self.cbPhonebookReply,
                    error_handler=self.cbPhonebookError
                )
                self.busy = True
            else:
                # Fake phonebook...
                self.cbPhonebookReply( [
                    (1, u'Kirk', '+023224433'),
                    (2, u'Spock', '+034433463'),
                    (3, u'McCoy', '+013244344'),
                    (4, u'Scott', '+013244344'),
                    (5, u'Uhura', '+013244344'),
                    (6, u'Sulu', '+013244344'),
                    (7, u'Chekov', '+456663443'),
                ] )

    def onReadyStatus( self, status ):
        logger.debug( "SIM is ready: %s" % status )
        if status:
            # Force update
            self.ready = False
            self.prepare()

    def onShow( self ):
        self.prepare()
        self.updateList()

    def comparePhoneNumber(self, number1, number2):
        '''
        Compares two phone numbers. They are considered equal if:
          a) One does not contain digits, and they are equal as strings
        or
          b) Both start with a "+", and all following digits are equal
        or
          c) At least one of them does not start with a "+", and the
             last 7 digits are equal
        '''
        digits1 = filter (lambda c: c.isdigit() or c == '+', number1)
        digits2 = filter (lambda c: c.isdigit() or c == '+', number2)

        if digits1 == '' or digits2 == '':
            return number1 == number2
        if digits1[0] == digits2[0] == '+':
            return digits1 == digits2
        else:
            return digits1[-7:] == digits2[-7:]

    def tryNumberToName( self, number ):
        for i in range( len( self.phonebook ) ):
            if self.comparePhoneNumber(self.phonebook[i][2], number):
                return self.phonebook[i][1]
        return number

    def updateList( self ):
        self.pages = max( ( len( self.phonebook ) - 1 ) / 6 + 1, 1 )
        if self.page >= self.pages:
            self.page = self.pages - 1
        if self.page < 0:
            self.page = 0
        self.current = self.phonebook[self.page*6:(self.page+1)*6]
        text = u"".join( [u"□"]*self.page+[u"▣"]+[u"□"]*(self.pages-self.page-1) )
        self.part_text_set( "pager", text )
        for i in range( 0, len( self.current ) ):
            self.part_text_set( "label_main_list_%i" % i, self.current[i][1] )
            self.part_text_set( "label_sub_list_%i" % i, self.current[i][2] )
        for i in range( len( self.current ), 6):
            self.part_text_set( "label_main_list_%i" % i, u"" )
            self.part_text_set( "label_sub_list_%i" % i, u"" )
        self.selected = None
        for i in range( 6 ):
            self.signal_emit( "deactivate_target_list_%i" % i, "" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if self.selected == id:
            return
        if self.selected is not None:
            self.signal_emit( "deactivate_target_list_%i" % self.selected, "" )
        self.signal_emit( "activate_target_list_%i" % id, "" )
        self.selected = id

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_left" )
    def on_edje_signal_button_action_left_pressed( self, emission, source ):
        self.page -= 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_right" )
    def on_edje_signal_button_action_right_pressed( self, emission, source ):
        self.page += 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_dial" )
    def on_edje_signal_button_action_dial_pressed( self, emission, source ):
        if self.selected is not None:
            if dbus_object.gsm_device_obj:
                dbus_object.gsm_call_iface.Initiate( self.current[self.selected][2], "voice" )
            else:
                # Fake onCallStatus...
                self.main.groups["call"].onCallStatus( None, "outgoing", {"peer": self.current[self.selected][2]} )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_bottom_middle" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.main.groups["menu"].activate(("edit name", "edit number", "new", "delete"), self.cbMenu)

#----------------------------------------------------------------------------#
class pyphone_location( edje_group ):
#----------------------------------------------------------------------------#
    class SignalGraph( evas.ClippedSmartObject ):
        def __init__( self, *args, **kargs ):
            evas.ClippedSmartObject.__init__( self, *args, **kargs )
            self.textheight = 45
            self.font = ( "Sans", 15 )
            self.children = []
            self.values = []
            self.maxvalue = None
            self.resized = 0

        def resize( self, w, h ):
            self.w = w
            self.h = h
            self.render()
            self.resized = 1

        def render( self ):
            x, y = self.pos
            if len ( self.children ) == 0:
                return
            barwidth = self.w / len( self.children )
            barheight = self.h - self.textheight
            for (rect, key_text, value_text), (key, value) in zip( self.children, self.values ):
                key_text.text = str( key )
                value_text.text = str( value )
                barlength = int( barheight*( value/self.maxvalue ) )
                valueoffset = max( self.textheight-barlength, 0 )
                rect.geometry = (
                    x+5, y+barheight-barlength,
                    barwidth-5, barlength
                )
                key_text.geometry = (
                    x+(barwidth-key_text.horiz_advance)/2, y+barheight,
                    barwidth, self.textheight
                )
                value_text.geometry = (
                    x+(barwidth-value_text.horiz_advance)/2, y+5+barheight-barlength-valueoffset,
                    barwidth, self.textheight
                )
                x += barwidth


        def addChild( self ):
            rect = self.Rectangle( color=( 0, 255, 0, 255 ) )
            rect.show()
            key_text = self.Text(
                style = evas.EVAS_TEXT_STYLE_SOFT_OUTLINE,
                outline_color = ( 0, 0, 0, 255 ),
                font = self.font
            )
            key_text.show()
            value_text = self.Text(
                style = evas.EVAS_TEXT_STYLE_SOFT_OUTLINE,
                outline_color = ( 0, 0, 0, 255 ),
                font = self.font
            )
            value_text.show()
            self.children.append( ( rect, key_text, value_text ) )

        def delChild( self ):
            child = self.children[-1]
            del self.children[-1]
            for x in child:
                self.member_del( x )

        def update( self, values = None ):
            if values is not None:
                self.values = values
                if values == []:
                    self.maxvalue = 1
                    self.values = [(0, 0)]
                else:
                    self.maxvalue = max( [ x[1] for x in values] )
                    if self.maxvalue == 0:
                        self.maxvalue = 1

            while len( self.children ) > len( self.values ):
                self.delChild()
            while len( self.children ) < len( self.values ):
                self.addChild()
            if self.resized:
                self.render()
            self.resize( *self.size )

    class PositionGraph( evas.ClippedSmartObject ):
        def __init__( self, *args, **kargs ):
            evas.ClippedSmartObject.__init__( self, *args, **kargs )
            self.img = self.Image()
            self.img.alpha = True
            self.img.colorspace = evas.EVAS_COLORSPACE_ARGB8888
            self.img.pos = self.pos
            self.img.show()
            self.surface = None
            self.ctx = None
            self.values = []

        def proj( self, azim, elev ):
            x = math.sin( math.radians( azim ) )*( elev/90.0 )
            y = math.cos( math.radians( azim ) )*( elev/90.0 )
            return ( x, y )

        def resize( self, w, h ):
            self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
            self.ctx = cairo.Context(self.surface)
            self.ctx.scale( w, h )
            #self.ctx.set_antialias( cairo.ANTIALIAS_NONE )
            self.img.image_size = ( w, h )
            self.update()
            self.img.resize( *self.img.image_size )
            self.img.fill_set(0, 0, *self.img.image_size )

        def update( self, values = None ):
            if values is not None:
                self.values = values
            if self.ctx:
                self.ctx.set_operator( cairo.OPERATOR_CLEAR )
                self.ctx.paint()
                self.ctx.set_operator( cairo.OPERATOR_OVER )
                self.ctx.set_line_width( max( self.ctx.device_to_user_distance( 2, 2 ) ) )
                #self.ctx.move_to(0.20, 0.10)
                #self.ctx.line_to(0.40, 0.30)
                #self.ctx.rel_line_to(-0.20, 0.0)
                #self.ctx.close_path()
                #self.ctx.stroke()
                # background
                self.ctx.set_source_rgba(1, 1, 1, 0.5)
                self.ctx.arc( 0.50, 0.50, 0.45, 0.0, math.pi*2 )
                self.ctx.fill()
                self.ctx.set_source_rgba(0, 0, 0, 1)
                self.ctx.arc( 0.50, 0.50, 0.45, 0.0, math.pi*2 )
                self.ctx.new_sub_path()
                self.ctx.arc( 0.50, 0.50, 0.30, 0.0, math.pi*2 )
                self.ctx.new_sub_path()
                self.ctx.arc( 0.50, 0.50, 0.15, 0.0, math.pi*2 )
                self.ctx.stroke()
                # locations
                for sv, azim, elev in self.values:
                    sv = str( sv )
                    x, y = self.proj( azim, elev )
                    self.ctx.set_source_rgba(0, 1, 0, 1)
                    self.ctx.arc(
                        0.50+x*0.45,
                        0.50+y*0.45,
                        max( self.ctx.device_to_user_distance( 15, 15 ) ),
                        0.0, math.pi*2
                    )
                    self.ctx.fill()
                    self.ctx.set_source_rgba(0, 0, 0, 1)
                    self.ctx.set_font_size( max( self.ctx.device_to_user_distance( 20, 20 ) ))
                    x_bearing, y_bearing, width, height = self.ctx.text_extents(sv)[:4]
                    self.ctx.move_to(
                        0.50+x*0.45 - width / 2 - x_bearing,
                        0.50+y*0.45 - height / 2 - y_bearing
                    )
                    self.ctx.show_text( sv )
                #self.surface.write_to_png( "/tmp/zhone-location.png" )
                #self.img.file_set( "/tmp/zhone-location.png" )
                self.img.image_data_set( self.surface.get_data() )

    def __init__(self, main):
        edje_group.__init__( self, main, "location" )
        self.signalgraph = self.SignalGraph( self.evas )
        self.positiongraph = self.PositionGraph( self.evas )

        self.page = "left"
        self.signal_emit( "activate_button_select_%s" % self.page, "" )

        self.accuracy = None
        self.position = None
        self.update()

        #self.signalgraph.update( [(1, 20.5), (2, 34.3), (5, 25.9), (10, 0.5)] )
        #self.positiongraph.update( [(1, 20.0, 90.0), (2, 34.3, 45.0), (5, 225.9, 0.0), (10, 0.5, 30.0)] )

    def update( self ):
        text = []
        if self.position:
            text.append( "Lat:<tab>%s<br>Lon:<tab>%s<br>Alt:<tab>%s" % self.position )
        else:
            text.append( "Lat:<tab>N/A<br>Lon:<tab>N/A<br>Alt:<tab>N/A" )
        if self.accuracy:
            text.append( "P/H/V-DOP:<tab>%s/%s/%s" % self.accuracy )
        else:
            text.append( "P/H/V-DOP:<tab>N/A")
        if self.page == "left":
            self.part_text_set( "status", u"<br>".join( text ) )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
        elif self.page == "middle":
            self.part_text_set( "status", u"" )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
            self.part_swallow( "swallow", self.signalgraph )
            self.signalgraph.show()
        elif self.page == "right":
            self.part_text_set( "status", u"" )
            if self.part_swallow_get( "swallow" ):
                self.part_swallow_get( "swallow" ).hide()
                self.part_unswallow( self.part_swallow_get( "swallow" ) )
            self.part_swallow( "swallow", self.positiongraph )
            self.positiongraph.show()

    def onAccuracyChanged( self, fields, pdop, hdop, vdop ):
        self.accuracy = ( pdop, hdop, vdop )
        self.update()

    def onPositionChanged( self, fields, timestamp, lat, lon, alt ):
        self.position = ( lat, lon, alt )
        self.update()

    def onSatellitesChanged( self, satellites ):
        if self.page == "middle":
            signallist = [ (int(sat[0]), float(sat[4])) for sat in satellites ]
            self.signalgraph.update( signallist )
        positionlist = [ (int(sat[0]), int(sat[3]), int(sat[2])) for sat in satellites ]
        self.positiongraph.update( positionlist )

    def onShow( self ):
        if dbus_object.usage_obj:
            dbus_object.usage_iface.RequestResource("GPS")
        self.update()

    def onHide( self ):
        if dbus_object.usage_obj:
            dbus_object.usage_iface.ReleaseResource("GPS")

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_select_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        self.page = source.split( "_" )[-1]
        self.signal_emit( "deactivate_button_select_left", "" )
        self.signal_emit( "deactivate_button_select_middle", "" )
        self.signal_emit( "deactivate_button_select_right", "" )
        self.signal_emit( "activate_button_select_%s" % self.page, "" )
        self.update()

#----------------------------------------------------------------------------#
class pyphone_message(edje_group):
#----------------------------------------------------------------------------#
    def __init__(self, main):
        edje_group.__init__(self, main, "message")
        self.text = []
        self.button_labels2 = [
            [
                [u".,?!", u"abc", "def", ""],
                [u"ghi", u"jkl", "mno", ""],
                [u"pqrs", u"tuv", "wxyz", ""],
                [u"", u"", u"⇦⇧⇨", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.button_labels = [
            [
                ["1", "2", "3", u"↤"],
                ["4", "5", "6", u"↲"],
                ["7", "8", "9", "Abc"],
                ["+", "0", u"⇩", "+"],
            ],
            [
                ["1", "?", "", ""],
                [".", ",", "", ""],
                ["!", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "2", "c", ""],
                ["", "a", "b", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "3", "f"],
                ["", "", "d", "e"],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", u"↤"],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["4", "i", "", ""],
                ["g", "h", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "5", "l", ""],
                ["", "j", "k", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "6", "o"],
                ["", "", "m", "n"],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "s", "", ""],
                ["7", "r", "", ""],
                ["p", "q", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "8", "v", ""],
                ["", "t", "u", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", "z"],
                ["", "", "9", "y"],
                ["", "", "w", "x"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", " ", "", ""],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", u"⇧", ""],
                ["", u"⇦", u"⇩", u"⇨"],
            ],
            [
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
                ["", "", "", ""],
            ]
        ]
        self.set_button_text(0)
        self.active = 0

    @edje.decorators.signal_callback("kb_button_mouse_up", "*")
    def on_edje_signal_dialer_button_mouse_up(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        key = self.button_labels[self.active][y][x]
        self.text.append(key)
        # The trailing whitespace is a workaround for the one char invisible
        # bug due to some problems with scaling of text parts.
        self.part_text_set("label", "".join(self.text)+" ")
        self.set_button_text(0)
        logger.debug( "mouse up: %s" % time.time()-now )

    @edje.decorators.signal_callback("kb_button_mouse_down", "*")
    def on_edje_signal_dialer_button_mouse_down(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        num = 4*y+x+1
        if self.active == 0:
            self.set_button_text(num)
        logger.debug( "mouse down: %s" % time.time()-now )

    @edje.decorators.signal_callback("kb_mutton_mouse_in", "*")
    def on_edje_signal_dialer_button_mouse_in(self, emission, source):
        now = time.time()
        x = int(source[-3:-2])
        y = int(source[-1:])
        self.part_text_set("label_preview", self.button_labels[self.active][y][x])
        logger.debug( "mouse in: %s" % time.time()-now )

    def set_button_text(self, num):
        for i in xrange(4):
            for j in xrange(4):
                text = self.button_labels[num][j][i]
                self.part_text_set("label_%d_%d" % (i,j) , text)
        self.active = num

        if num != 0:
            num = 1

        for i in xrange(4):
            for j in xrange(4):
                text = self.button_labels2[num][j][i]
                self.part_text_set("label2_%d_%d" % (i,j) , text)

#----------------------------------------------------------------------------#
class pyphone_list_choose(edje_group):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "list_choose" )
        self.text = ""
        self.list_data = None
        self.cb_data = None
        self.cb = None

    def updateList( self):
        self.pages = max( ( len( self.list_data ) - 1 ) / 6 + 1, 1 )
        if self.page >= self.pages:
            self.page = self.pages - 1
        if self.page < 0:
            self.page = 0
        self.current = self.list_data[self.page*6:(self.page+1)*6]
        self.part_text_set( "pager", u"".join( [u"□"]*self.page+[u"▣"]+[u"□"]*(self.pages-self.page-1) ) )
        for i in range( 0, len( self.current ) ):
            self.part_text_set( "label_main_list_%i" % i, self.current[i][0] )
            self.part_text_set( "label_sub_list_%i" % i, self.current[i][1] )
        for i in range( len( self.current ), 6):
            self.part_text_set( "label_main_list_%i" % i, u"" )
            self.part_text_set( "label_sub_list_%i" % i, u"" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        self.main.transition_to(self.parent_name)
        self.cb( self.current[id], self.cb_data )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_left" )
    def on_edje_signal_button_action_left_pressed( self, emission, source ):
        self.page -= 1
        self.updateList()

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_action_right" )
    def on_edje_signal_button_action_right_pressed( self, emission, source ):
        self.page += 1
        self.updateList()

    def setup( self, parent_name, list_data, cb_data, cb ):
        self.parent_name = parent_name
        self.list_data = list_data
        self.cb_data = cb_data
        self.cb = cb

        self.current = []
        self.page = 0
        self.main.transition_to("list_choose")

        self.updateList()

#----------------------------------------------------------------------------#
class pyphone_number_edit( edje_group ):
#----------------------------------------------------------------------------#
    TIMEOUT = 2.0
    def __init__( self, main ):
        edje_group.__init__( self, main, "number_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None
        self.last = 0.0

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key in ( "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "#" ):
            self.text += key
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "star":
            if self.text and ( time.time()-self.last < self.TIMEOUT ):
                if self.text[-1] == "*":
                    self.text = self.text[:-1]+"+"
                elif self.text[-1] == "+":
                    self.text = self.text[:-1]+"*"
                else:
                    self.text += "*"
            else:
                self.text += "*"
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "hash":
            self.text += "#"
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "delete":
            self.text = self.text[:-1]
            self.part_text_set( "label", u" %s " % self.text )
        elif key in "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
        self.last = time.time()

    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", u" %s " % self.title )
        self.part_text_set( "label", u" %s " % self.text )
        self.main.transition_to("number_edit")

#----------------------------------------------------------------------------#
class pyphone_pin_edit( edje_group ):
#----------------------------------------------------------------------------#
    DELAY = 1.0
    def __init__( self, main ):
        edje_group.__init__( self, main, "number_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None
        self.timer = None
        self.last = 0.0
        self.part_text_set( "label_main_star", u"" )
        self.part_text_set( "label_sub_star", u"" )
        self.part_text_set( "label_main_hash", u"" )
        self.part_text_set( "label_sub_hash", u"" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key in ( "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ):
            self.text += key
            # The trailing whitespace is a workaround for the one char invisible
            # bug due to some problems with scaling of text parts.
            output = u"●"*( len( self.text ) - 1) + self.text[-1]
            self.part_text_set( "label", u" %s " % output )
            if self.timer:
                self.timer.delete()
            self.timer = ecore.timer_add( self.DELAY, self.timerCb )
        elif key in "delete":
            self.text = self.text[:-1]
            output = u"●"*len( self.text )
            self.part_text_set( "label", u" %s " % output )
        elif key in "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
        self.last = time.time()

    def timerCb( self ):
        output = u"●"*len( self.text )
        self.part_text_set( "label", u" %s " % output )
        self.timer = None
        return False

    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", u" %s " % self.title )
        self.part_text_set( "label", u" %s " % self.text )
        self.main.transition_to("pin_edit")

#----------------------------------------------------------------------------#
class pyphone_text_show( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "text_show" )

    def setup( self, parent_name, text ):
        self.parent_name = parent_name
        self.part_text_set( "text", text )
        self.main.transition_to("text_show")

#----------------------------------------------------------------------------#
class pyphone_text_edit( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "text_edit" )
        self.text = ""
        self.cb_data = None
        self.cb = None
        self.shift_down = False

    def onShow( self ):
        self.focus = True
        if illume:
            illume.kbd_show()

    def onHide( self ):
        self.focus = False
        if illume:
            illume.kbd_hide()

    @evas.decorators.key_down_callback
    def on_key_down( self, event ):
        key = event.string
        if key == "\x08":
            self.text = self.text[:-1]
        elif key is not None:
            self.text += key
        self.part_text_set( "label", self.text )

    @edje.decorators.signal_callback( "mouse,clicked,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        key = source.split( "_", 1 )[1]
        if key == "done":
            self.main.transition_to(self.parent_name)
            self.cb( self.text, self.cb_data )
        elif key == "cancel":
            self.main.transition_to(self.parent_name)

    def setup( self, parent_name, text, title, cb_data, cb ):
        self.parent_name = parent_name
        self.text = text
        self.title = title
        self.cb_data = cb_data
        self.cb = cb
        self.part_text_set( "label_description", u" %s " % self.title )
        self.part_text_set( "label", self.text )
        self.main.transition_to("text_edit")

#----------------------------------------------------------------------------#
class pyphone_menu( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "menu" )
        self.buttons = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_*" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        if source == "target_cancel":
            self.deactivate()
            self.cb( "cancel" )
        else:
            id = int( source.split( "_", 1 )[1] )
            self.deactivate()
            self.cb( self.part_text_get( "target_label_%i" % id ) )

    def activate( self, buttons, cb ):
        self.buttons = buttons
        self.cb = cb
        count = len( buttons )
        assert count == 4
        self.part_text_set( "target_label_0", buttons[0] )
        self.part_text_set( "target_label_1", buttons[1] )
        self.part_text_set( "target_label_2", buttons[2] )
        self.part_text_set( "target_label_3", buttons[3] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )


#----------------------------------------------------------------------------#
class pyphone_main_menu( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "main_menu" )
        self.signal_emit( "invisible", "" )

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_list_*" )
    def on_edje_signal_button_list_pressed( self, emission, source ):
        id = int( source.split( "_" )[-1] )
        if( id == 5 ):
          os.system("halt")
        if( id == 0 ):
          fp = os.popen("sleep 5 && \
                         n=/tmp/scap$$.png && \
                         fbgrab $n && \
                         curl \
                          -F file=@$n \
                          -F key=secret \
                          -F model=`uname -n` \
                          -F submit=Upload \
                          -F text=no\ comment \
                          http://scap.linuxtogo.org/tickle.php && \
                         rm $n &")

    @edje.decorators.signal_callback( "mouse,clicked,1", "target_cancel" )
    def on_edje_signal_button_bottom_middle_pressed( self, emission, source ):
        self.deactivate()

    def activate( self, group ):
        self.group = group
        self.signal_emit( "visible", "" )
        for i in range( 1, 5 ):
          self.part_text_set( "label_main_list_%i" % i, u"" )
          self.part_text_set( "label_sub_list_%i" % i, u"" )
        
        self.part_text_set( "label_main_list_0", u"Take screenshot" )
        self.part_text_set( "label_sub_list_0", u"and upload to http://scap.linuxtogo.org" )
        self.part_text_set( "label_main_list_5", u"Exit" )
        self.part_text_set( "label_sub_list_5", u"Stop and exit Zhone" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )
        self.main.transition_to(self.group)


#----------------------------------------------------------------------------#
class pyphone_lock( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "lock" )
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "target_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        if id == self.step+1: # correct button
            self.signal_emit( "activate_%i" % id, "" )
            self.step += 1
        else:
            for id in range( 1, 5 ):
                self.signal_emit( "deactivate_%i" % id, "" )
            self.step = 0
        if self.step == 4:
            self.signal_emit( "invisible", "" )

    def activate( self ):
        self.step = 0
        for id in range( 1, 5 ):
            self.signal_emit( "deactivate_%i" % id, "" )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class pyphone_error( edje_group ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        edje_group.__init__( self, main, "error" )
        self.buttons = None
        self.cb_data = None
        self.cb = None
        self.deactivate()

    @edje.decorators.signal_callback( "mouse,down,1", "button_*" )
    def on_edje_signal_button_pressed( self, emission, source ):
        id = int( source.split( "_", 1 )[1] )
        self.deactivate()
        self.cb( self.part_text_get( "label_%i" % id ), self.cb_data )

    def activate( self, description, buttons, cb_data, cb ):
        self.buttons = buttons
        self.cb_data = cb_data
        self.cb = cb
        count = len( buttons )
        assert 1 <= count <= 3
        self.part_text_set( "description", description )
        if count == 1:
            self.signal_emit( "hide_0", "" )
            self.part_text_set( "label_0", u"" )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[0] )
            self.signal_emit( "hide_2", "" )
            self.part_text_set( "label_2", u"" )
        elif count == 2:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "hide_1", "" )
            self.part_text_set( "label_1", u"" )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[1] )
        elif count == 3:
            self.signal_emit( "show_0", "" )
            self.part_text_set( "label_0", buttons[0] )
            self.signal_emit( "show_1", "" )
            self.part_text_set( "label_1", buttons[1] )
            self.signal_emit( "show_2", "" )
            self.part_text_set( "label_2", buttons[2] )
        self.signal_emit( "visible", "" )

    def deactivate( self ):
        self.signal_emit( "invisible", "" )

#----------------------------------------------------------------------------#
class GSMAgent( object ):
#----------------------------------------------------------------------------#
    def __init__( self, main ):
        self.main = main
        self.state = "Waiting for DBus"
        self.onState = []

    def setState( self, state ):
        logger.debug( state )
        self.state = state
        for cb in self.onState:
            cb( state )

    def cbDBusReady( self ):
        """
        This is called to start the authentication process
        """
        self.setState( "Reading authentication status" )
        dbus_object.gsm_sim_iface.GetAuthStatus(
            reply_handler=self.cbAuthStatusReply,
            error_handler=self.cbAuthStatusError
        )

    def cbAuthStatusReply( self, authstatus ):
        if authstatus == "READY":
            self.setState( "Enabling GSM" )
            dbus_object.gsm_device_iface.SetAntennaPower(
                True,
                reply_handler=self.cbAntennaPowerReply,
                error_handler=self.cbAntennaPowerError
            )
        elif authstatus == "SIM PIN":
            self.setState( "Waiting for PIN" )
            self.main.groups["pin_edit"].setup(
                "main",
                "", # number
                "Enter PIN", # title
                None, # reference
                self.cbPINDone
            )
        elif authstatus == "SIM PUK":
            self.setState( "Waiting for PUK" )
            self.main.groups["pin_edit"].setup(
                "main",
                "", # number
                "Enter PUK", # title
                None, # reference
                self.cbPUKDone
            )
        else:
            logger.exception( "Unkown authentication status %s" % authstatus )

    def cbAuthStatusError( self, e ):
        self.setState( "Failed to read authentication status" )
        logger.exception( e )

    def cbPINDone( self, pin, *args ):
        self.setState( "Sending PIN" )
        dbus_object.gsm_sim_iface.SendAuthCode(
            pin,
            reply_handler=self.cbAuthCodeReply,
            error_handler=self.cbAuthCodeError
        )

    def cbAuthCodeReply( self ):
        self.cbAuthStatusReply( "READY" )

    def cbAuthCodeError( self, e ):
        self.setState( "Error while sending PIN" )
        logger.exception( e )
        # retry
        self.cbDBusReady()

    def cbPUKDone( self, puk, *args ):
        self.main.groups["pin_edit"].setup(
            "main",
            "", # number
            "Enter new PIN", # title
            puk, # reference
            self.cbNewPINDone
        )

    def cbNewPINDone( self, pin, puk ):
        self.setState( "Sending PUK and new PIN" )
        dbus_object.gsm_sim_iface.Unlock(
            pin, puk,
            reply_handler=self.cbUnlockReply,
            error_handler=self.cbUnlockError
        )

    def cbUnlockReply( self ):
        self.cbAuthStatusReply( "READY" )

    def cbUnlockError( self, e ):
        self.setState( "Error while sending PIN" )
        logger.exception( e )
        # retry
        self.cbDBusReady()

    def cbAntennaPowerReply( self ):
        self.setState( "Registering to network" )
        dbus_object.gsm_network_iface.Register(
            reply_handler=self.cbRegisterReply,
            error_handler=self.cbRegisterError
        )

    def cbAntennaPowerError( self, e ):
        self.setState( "Failed to enable GSM" )
        logger.exception( e )

    def cbRegisterReply( self ):
        self.setState( "Registered to network" )
        self.main.groups["main"].targets["phone"] = True
        self.main.groups["main"].update()
        if dbus_object.gsm_sim_iface.GetSimReady():
            self.main.groups["contacts"].prepare()
            self.main.groups["sms"].prepare()

    def cbRegisterError( self, e ):
        self.setState( "Failed to register to network" )
        logger.exception( e )

#----------------------------------------------------------------------------#
class GUI(object):
#----------------------------------------------------------------------------#
    def __init__( self, options, args ):

        logger.debug( "GUI init" )

        edje.frametime_set(1.0 / options.fps)

        self.evas_canvas = EvasCanvas(
            fullscreen = options.fullscreen,
            engine = options.engine,
            size = options.geometry
        )

        self.agents = {}

        self.agents["gsm"] = GSMAgent( self )

        self.groups = {}

        self.groups["swallow"] = edje_group(self, "swallow")
        self.evas_canvas.evas_obj.data["swallow"] = self.groups["swallow"]

        for page in (
                "main",
                "phone", "call", "dtmf",
                "sms",
                "contacts",
                "location",
                "configuration",
                "list_choose", "number_edit", "pin_edit", "text_edit", "text_show", "message"
            ):
            ctor = globals().get( "pyphone_%s" % page, None )
            if ctor:
                self.groups[page] = ctor( self )
                self.evas_canvas.evas_obj.data[page] = self.groups[page]

        for overlay in ("main_menu", "menu", "lock", "error" ):
            ctor = globals().get( "pyphone_%s" % overlay, None )
            if ctor:
                self.groups[overlay] = ctor( self )
                self.evas_canvas.evas_obj.data[overlay] = self.groups[overlay]
                self.groups["swallow"].part_swallow( overlay, self.groups[overlay] )

        self.groups["swallow"].show()

        self.current_group = self.groups[options.start]
        self.previous_group = None
        self.groups["swallow"].part_swallow("swallow", self.current_group)
        ecore.timer_add(60.0, self.display_time)
        self.display_time()

        ecore.idle_enterer_add( self.dbus_objectInit )

        dbus_object.onAccuracyChanged.append( self.groups["location"].onAccuracyChanged )
        dbus_object.onPositionChanged.append( self.groups["location"].onPositionChanged )
        dbus_object.onSatellitesChanged.append( self.groups["location"].onSatellitesChanged )
        dbus_object.onCallStatus.append( self.groups["call"].onCallStatus )
        dbus_object.onReadyStatus.append( self.groups["contacts"].onReadyStatus )
        dbus_object.onReadyStatus.append( self.groups["sms"].onReadyStatus )
        dbus_object.onIncomingMessage.append( self.groups["sms"].onIncomingMessage )
        dbus_object.onIdleStateChanged.append( self.lock_on_idle )

        logger.debug( "GUI init done" )

    def run( self ):
        logger.debug( "entering mainloop" )
        ecore.main_loop_begin()

    def shutdown( self ):
        ecore.main_loop_quit()

    def dbus_objectInit( self ):
        logger.debug( "dbus_objectInit..." )
        if not dbus_object.initialize():
            # try again later
            ecore.timer_add( 10.0, self.dbus_objectInit )
            return False
        else:
            self.dbus_objectInitOK()
        return False

    def dbus_objectInitOK( self ):
        logger.debug( "dbus_objectInitOK!" )

        if dbus_object.gsm_device_obj is not None:
            self.agents["gsm"].cbDBusReady()
        if dbus_object.gps_obj is not None:
            self.groups["main"].targets["location"] = True
            self.groups["main"].update()

    def lock_on_idle( self, state ):
        if state == "LOCK":
            self.groups["lock"].activate()

    def display_time(self):
        self.groups["main"].part_text_set("label", time.strftime("%H:%M", time.localtime()))
        self.groups["main"].part_text_set("label_year", time.strftime("%Y-%m-%d", time.localtime()))
        return True

    # TODO better state management for transitions
    def transition_to(self, target):
        if self.current_group == self.groups[target]:
            return
        logger.debug( "transition to %s" % target )

        self.previous_group = self.current_group
        self.previous_group.onHide()
        self.previous_group.hide()

        self.current_group = self.groups[target]
        self.current_group.onShow()
        self.current_group.signal_emit("visible", "")
        self.groups["swallow"].part_swallow("swallow", self.current_group)
        self.previous_group.signal_emit("invisible", "")

#----------------------------------------------------------------------------#
class EvasCanvas(object):
#----------------------------------------------------------------------------#
    def __init__(self, fullscreen, engine, size):
        if engine == "x11":
            f = ecore.evas.SoftwareX11
        elif engine == "x11-16":
            if ecore.evas.engine_type_supported_get("software_x11_16"):
                f = ecore.evas.SoftwareX11_16
            else:
                logger.warning( "x11-16 is not supported, fallback to x11" )
                f = ecore.evas.SoftwareX11

        self.evas_obj = f(w=size[0], h=size[1])
        self.evas_obj.callback_delete_request = self.on_delete_request
        self.evas_obj.callback_resize = self.on_resize

        self.evas_obj.title = TITLE
        self.evas_obj.name_class = (WM_NAME, WM_CLASS)
        self.evas_obj.fullscreen = fullscreen
        self.evas_obj.size = size
        self.evas_obj.evas.image_cache_set( 6*1024*1024 )
        self.evas_obj.evas.font_cache_set( 2*1024*1024 )
        self.evas_obj.show()

    def on_resize(self, evas_obj):
        x, y, w, h = evas_obj.evas.viewport
        size = (w, h)
        evas_obj.data["swallow"].size = size

    def on_delete_request(self, evas_obj):
        ecore.main_loop_quit()

#----------------------------------------------------------------------------#
class MyOptionParser(OptionParser):
#----------------------------------------------------------------------------#
    def __init__(self):
        OptionParser.__init__(self)
        self.set_defaults(fullscreen = False)
        self.add_option("-e",
                      "--engine",
                      type="choice",
                      choices=("x11", "x11-16"),
                      default="x11-16",
                      help=("which display engine to use (x11, x11-16), "
                            "default=%default"))
        self.add_option("--fullscreen",
                      action="store_true",
                      dest="fullscreen",
                      help="launch in fullscreen")
        self.add_option("--no-fullscreen",
                      action="store_false",
                      dest="fullscreen",
                      help="launch in a window")
        self.add_option("-g",
                      "--geometry",
                      type="string",
                      metavar="WxH",
                      action="callback",
                      callback=self.parse_geometry,
                      default=(WIDTH, HEIGHT),
                      help="use given window geometry")
        self.add_option("-f",
                      "--fps",
                      type="int",
                      default=20,
                      help="frames per second to use, default=%default")
        self.add_option("-s",
                      "--start",
                      type="string",
                      default="main",
                      help="start with the given page")

    def parse_geometry(option, opt, value, parser):
        try:
            w, h = value.split("x")
            w = int(w)
            h = int(h)
        except Exception, e:
            raise optparse.OptionValueError("Invalid format for %s" % option)
        parser.values.geometry = (w, h)

#----------------------------------------------------------------------------#
class DBusObject( object ):
#----------------------------------------------------------------------------#
    def __init__( self ):
        self.objects = {}
        self.onResourceChanged = []
        self.onAccuracyChanged = []
        self.onPositionChanged = []
        self.onSatellitesChanged = []
        self.onCallStatus = []
        self.onReadyStatus = []
        self.onNetworkStatus = []
        self.onIncomingMessage = []
        self.onIdleStateChanged = []

        self.framework_obj = None

        self.usage_obj = None
        self.usage_iface = None

        self.gps_obj = None
        self.gps_accuracy_iface = None
        self.gps_position_iface = None
        self.gps_satellite_iface = None

        self.gsm_device_obj = None
        self.gsm_device_iface = None
        self.device_iface = None
        self.device_power_iface = None
        self.idlenotifier_obj = None
        self.idlenotifier_iface = None
        self.inputnotifier_obj = None
        self.inputnotifier_iface = None
        self.display_obj = None
        self.display_iface = None
        self.prefs_obj = None
        self.prefs_iface = None

        self.fullinit = False

        self.willSuspend = False

    def tryGetProxy( self, busname, objname ):
        object = None
        try:
            object = self.objects[ "%s:%s" % ( busname, objname ) ]
        except KeyError:
            try:
                object = self.bus.get_object( busname, objname )
            except DBusException, e:
                logger.warning( "could not create proxy for %s:%s" % ( busname, objname ) )
            else:
                self.objects[ "%s:%s" % ( busname, objname ) ] = object
        return object

    def initialize( self ):
        if self.fullinit:
            return True
        try:
            self.bus = SystemBus( mainloop=e_dbus.DBusEcoreMainLoop() )
        except DBusException, e:
            logger.error( "could not connect to dbus_object system bus: %s" % e )
            return False

        # Framework
        fw_obj = self.tryGetProxy( 'org.freesmartphone.frameworkd', '/org/freesmartphone/Framework' )
        if fw_obj is None:
            logger.error( "could not connect to org.freesmartphone.frameworkd -- is the framework daemon started?" )
            return False
        else:
            self.fw = Interface( fw_obj, "org.freesmartphone.Objects" )
        failcount = 0

        # Usage
        self.usage_obj = self.tryGetProxy( 'org.freesmartphone.ousaged', '/org/freesmartphone/Usage' )
        if ( self.usage_obj is not None ) and ( self.usage_iface is None ):
            self.usage_iface = Interface(self.usage_obj, 'org.freesmartphone.Usage')
            self.usage_iface.connect_to_signal( "ResourceChanged", self.cbResourceChanged )
            self.usage_iface.RequestResource("GSM")
        if self.usage_obj is None:
            failcount += 1
        else:
            logger.debug( "usage ok: %s" % self.usage_iface )

        # GPS
        self.gps_obj = self.tryGetProxy( 'org.freesmartphone.ogpsd', '/org/freedesktop/Gypsy' )
        if self.gps_obj and not self.gps_accuracy_iface:
            self.gps_accuracy_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Accuracy')
            self.gps_accuracy_iface.connect_to_signal( "AccuracyChanged", self.cbAccuracyChanged )
        if self.gps_obj and not self.gps_position_iface:
            self.gps_position_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Position')
            self.gps_position_iface.connect_to_signal( "PositionChanged", self.cbPositionChanged )
        if self.gps_obj and not self.gps_satellite_iface:
            self.gps_satellite_iface = Interface(self.gps_obj, 'org.freedesktop.Gypsy.Satellite')
            self.gps_satellite_iface.connect_to_signal( "SatellitesChanged", self.cbSatellitesChanged )
        if not self.gps_obj or not self.gps_accuracy_iface or not self.gps_position_iface \
            or not self.gps_satellite_iface:
            failcount += 1
        else:
            logger.debug( "gps ok: %s, %s, %s" % ( self.gps_accuracy_iface, self.gps_position_iface, self.gps_satellite_iface ) )

        # Phone
        self.gsm_device_obj = self.tryGetProxy( 'org.freesmartphone.ogsmd', '/org/freesmartphone/GSM/Device' )

        if ( self.gsm_device_obj is not None ) and ( self.gsm_device_iface is None ):
            self.gsm_device_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Device')
            self.gsm_sim_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.SIM')
            self.gsm_network_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Network')
            self.gsm_call_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Call')
            self.gsm_test_iface = Interface(self.gsm_device_obj, 'org.freesmartphone.GSM.Test')
            self.gsm_sim_iface.connect_to_signal( "IncomingMessage", self.cbIncomingMessage )
            self.gsm_sim_iface.connect_to_signal( "ReadyStatus", self.cbReadyStatus )
            self.gsm_call_iface.connect_to_signal( "CallStatus", self.cbCallStatus )
            self.gsm_network_iface.connect_to_signal( "Status", self.cbNetworkStatus )
        if self.gsm_device_obj is None:
            failcount += 1
        else:
            logger.debug( "gsm ok: %s" % self.gsm_network_iface )

        self.device_obj = self.tryGetProxy( 'org.freesmartphone.odeviced', '/org/freesmartphone/Device' )
        if ( self.device_obj is not None ) and ( self.device_iface is None ):
            self.device_iface = Interface( self.device_obj, 'org.freesmartphone.Device' )

            self.device_power_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.PowerSupply" )[0] )
            self.device_power_iface = Interface(self.device_power_obj, 'org.freesmartphone.Device.PowerSupply')

            self.idlenotifier_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.IdleNotifier" )[0] )

            self.idlenotifier_iface = Interface( self.idlenotifier_obj, "org.freesmartphone.Device.IdleNotifier" )
            self.idlenotifier_iface.connect_to_signal( "State", self.cbIdleStateChanged )

            self.inputnotifier_obj = self.bus.get_object( "org.freesmartphone.odeviced", "/org/freesmartphone/Device/Input" )
            self.inputnotifier_iface = Interface( self.inputnotifier_obj, "org.freesmartphone.Device.Input" )
            self.inputnotifier_iface.connect_to_signal( "Event", self.cbEvent )

            logger.debug( "displays: %s" % self.fw.ListObjectsByInterface( "org.freesmartphone.Device.Display" ) )
            self.display_obj = self.tryGetProxy( "org.freesmartphone.odeviced", self.fw.ListObjectsByInterface( "org.freesmartphone.Device.Display" )[0] )
            if self.display_obj is not None:
                self.display_iface = Interface( self.display_obj, "org.freesmartphone.Device.Display" )
                self.display_iface.SetBrightness( 90 )
        if self.device_obj is None:
            failcount += 1
        else:
            logger.debug( "device ok: %s" % self.device_iface )

        # Prefs
        self.prefs_obj = self.tryGetProxy( 'org.freesmartphone.opreferencesd', '/org/freesmartphone/Preferences' )
        self.prefs_iface = Interface( self.prefs_obj, 'org.freesmartphone.Preferences' )
        logger.debug( "preferences ok: %s" % self.prefs_iface )

        logger.debug( "failcount = %d" % failcount )
        if failcount == 0:
            self.fullinit = True
        return self.fullinit

    def cbResourceChanged( self, resourcename, state, attributes ):
        for cb in self.onResourceChanged:
            cb( resourcename=resourcename, state=state, attributes=attributes )

    def cbAccuracyChanged( self, fields, pdop, hdop, vdop ):
        for cb in self.onAccuracyChanged:
            cb( fields=fields, pdop=pdop, hdop=hdop, vdop=vdop )

    def cbPositionChanged( self, fields, timestamp, lat, lon, alt ):
        for cb in self.onPositionChanged:
            cb( fields=fields, timestamp=timestamp, lat=lat, lon=lon, alt=alt )

    def cbSatellitesChanged( self, satellites ):
        for cb in self.onSatellitesChanged:
            cb( satellites )

    def cbCallStatus( self, id, status, properties ):
        logger.info( "CALL STATUS = %d, %s, %s" % ( id, status, properties ) )
        if self.idlenotifier_iface is not None:
            self.idlenotifier_iface.SetState("BUSY")
        for cb in self.onCallStatus:
            cb( id=id, status=status, properties=properties )

    def cbReadyStatus( self, status ):
        for cb in self.onReadyStatus:
            cb( status=status )

    def cbNetworkStatus( self, status ):
        for cb in self.onNetworkStatus:
            cb( status=status )

    def cbIncomingMessage( self, index ):
        for cb in self.onIncomingMessage:
            cb( index=index )

    def cbIdleStateChanged( self, state ):
        logger.info( "IDLE STATE = %s" % state )
        for cb in self.onIdleStateChanged:
            cb( state=state )
        if state == "BUSY":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 90 )
        elif state == "IDLE_DIM":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 20 )
        elif state == "IDLE_PRELOCK":
            if self.display_iface is not None:
                self.display_iface.SetBrightness( 0 )

    def cbEvent( self, name, action, seconds ):
        logger.info( "INPUT EVENT = %s, %s, %d" % ( name, action, seconds ) )
        if name+action == "AUXpressed":
            # FIXME launch transition to main screen
            pass

        elif name+action == "POWERheld":
            self.willSuspend = ( seconds >= 1 )

        elif name+action == "POWERreleased":
            if self.willSuspend:
                self.willSuspend = False
                self.gsm_device_iface.PrepareForSuspend()
                logger.info( "ENTERING SUSPEND" )
                os.system( "apm -s" )
                logger.info( "RETURN FROM SUSPEND" )
                self.gsm_device_iface.RecoverFromSuspend()
                self.idlenotifier_iface.SetState("BUSY")

#=========================================================================#
if __name__ == "__main__":
#=========================================================================#

    options, args = MyOptionParser().parse_args()
    dbus_object = DBusObject()
    gui = GUI( options, args )
    try:
        gui.run()
    except KeyboardInterrupt:
        gui.shutdown()
        del gui
